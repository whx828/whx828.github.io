<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>whx's Blog</title>
    <subtitle>Welcome to my blog!</subtitle>
    <updated>2023-04-09T19:04:02.958932+08:00</updated>
    <id>http://whx828.github.io</id>
    <link href="http://whx828.github.io/feed.xml" rel="self" type="application/atom+xml" />
    <link href="http://whx828.github.io" rel="alternate" type="text/html" />
    <generator uri="https://github.com/zineland/zine" version="0.6.0">zine</generator>
    <author>
        <name>whx's Blog</name>
        <uri>http://whx828.github.io</uri>
    </author>

    <entry>
        <title>从 Happened-before 说起（2）</title>
        <link rel="alternate" href="http://whx828.github.io/s3/4" type="text/html" title="从 Happened-before 说起（2）" />
        <published>2023-04-03</published>
        <updated>2023-04-03</updated>
        <id>http://whx828.github.io/s3/4</id>
        <content type="html" xml:base="http://whx828.github.io/s3/4">
            <![CDATA[<p>书接上文，继续讨论那个让人疑惑的问题。<br />
为了方便讨论，我把代码挪过来：</p>
<pre style="background-color:#fafafa;">
<span style="color:#fa6e32;">static</span><span style="color:#61676c;"> X</span><span style="color:#61676ccc;">:</span><span style="color:#61676c;"> AtomicI32 </span><span style="color:#ed9366;">= </span><span style="color:#61676c;">AtomicI32</span><span style="color:#ed9366;">::</span><span style="color:#61676c;">new(</span><span style="color:#ff8f40;">0</span><span style="color:#61676c;">)</span><span style="color:#61676ccc;">;
</span><span style="color:#fa6e32;">static</span><span style="color:#61676c;"> Y</span><span style="color:#61676ccc;">:</span><span style="color:#61676c;"> AtomicI32 </span><span style="color:#ed9366;">= </span><span style="color:#61676c;">AtomicI32</span><span style="color:#ed9366;">::</span><span style="color:#61676c;">new(</span><span style="color:#ff8f40;">0</span><span style="color:#61676c;">)</span><span style="color:#61676ccc;">;
</span><span style="color:#61676c;">
</span><span style="color:#fa6e32;">fn </span><span style="color:#f29718;">a</span><span style="color:#61676c;">() {
</span><span style="color:#61676c;">    X</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">store</span><span style="color:#61676c;">(</span><span style="color:#ff8f40;">10</span><span style="color:#61676ccc;">,</span><span style="color:#61676c;"> Relaxed)</span><span style="color:#61676ccc;">;    </span><span style="font-style:italic;color:#abb0b6;">// 1
</span><span style="color:#61676c;">    Y</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">store</span><span style="color:#61676c;">(</span><span style="color:#ff8f40;">20</span><span style="color:#61676ccc;">,</span><span style="color:#61676c;"> Relaxed)</span><span style="color:#61676ccc;">;    </span><span style="font-style:italic;color:#abb0b6;">// 2
</span><span style="color:#61676c;">}
</span><span style="color:#61676c;">
</span><span style="color:#fa6e32;">fn </span><span style="color:#f29718;">b</span><span style="color:#61676c;">() {
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">let</span><span style="color:#61676c;"> y </span><span style="color:#ed9366;">=</span><span style="color:#61676c;"> Y</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">load</span><span style="color:#61676c;">(Relaxed)</span><span style="color:#61676ccc;">; </span><span style="font-style:italic;color:#abb0b6;">// 3
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">let</span><span style="color:#61676c;"> x </span><span style="color:#ed9366;">=</span><span style="color:#61676c;"> X</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">load</span><span style="color:#61676c;">(Relaxed)</span><span style="color:#61676ccc;">; </span><span style="font-style:italic;color:#abb0b6;">// 4
</span><span style="color:#61676c;">    </span><span style="color:#f07171;">println!</span><span style="color:#61676c;">(</span><span style="color:#86b300;">&quot;</span><span style="color:#ff8f40;">{x} {y}</span><span style="color:#86b300;">&quot;</span><span style="color:#61676c;">)</span><span style="color:#61676ccc;">;
</span><span style="color:#61676c;">}
</span></pre>
<blockquote>
<p>More interestingly, the output can also be 0 20, even though there is no possible globally consistent order of the four operations that would result in this outcome. When 3 is executed, there is no happens-before relationship with 2, which means it could load either 0 or 20. When 4 is executed, there is no happens-before relationship with 1, which means it could load either 0 or 10. Given this, the output 0 20 is a valid outcome.<br />
更有趣的是，输出也可以是 0 20，即使没有可能导致此结果的四个操作的全局一致顺序。当 3 执行时，与 2 没有 happens-before 关系，也就是说它可以加载 0 或 20。当 4 执行时，与 1 没有 happens-before 关系，这意味着它可以加载 0 或 10。鉴于此，输出 0 20 是一个有效的结果。</p>
</blockquote>
<p>想要彻底搞明白，还得从概念的细节下手：</p>
<blockquote>
<p>…the basic happens-before rule is that everything that happens within the same thread happens in order. In this case: 1 happens-before 2, and 3 happens-before 4. Since we use relaxed memory ordering, there are no other happens-before relationships in our example.<br />
……基本的 happens-before 规则是同一线程内发生的所有事情都按顺序发生。在这种情况下：1 happens-before 2，3 happens-before 4。由于我们使用 <code>Relaxed</code> 内存排序，因此在我们的示例中没有其他 happens-before 关系。</p>
</blockquote>
<p>那到底什么是 happened-before？这里是维基百科给的定义：</p>
<p>In <a href="https://www.wikiwand.com/en/Computer_science" title="Computer science">computer science</a>, the <strong>happened-before</strong> <a href="https://www.wikiwand.com/en/Binary_relation" title="Binary relation">relation</a> (denoted: →) is a relation between the result of two events, such that if one event should happen before another event, the result must reflect that, even if those events are in reality executed out of order (usually to optimize program flow). This involves <a href="https://www.wikiwand.com/en/Partially_ordered_set" title="Partially ordered set">ordering</a> events based on the potential <a href="https://www.wikiwand.com/en/Causal_relationships" title="Causal relationships">causal relationship</a> of pairs of events in a concurrent system, especially <a href="https://www.wikiwand.com/en/Asynchronous_communication" title="Asynchronous communication">asynchronous</a> <a href="https://www.wikiwand.com/en/Distributed_systems" title="Distributed systems">distributed systems</a>. It was formulated by <a href="https://www.wikiwand.com/en/Leslie_Lamport" title="Leslie Lamport">Leslie Lamport</a>.<a href="https://www.wikiwand.com/en/Happened-before#cite_note-1">[1]</a><br />
在计算机科学中，happened-before 关系（表示为：→）是两个事件的结果之间的关系，这样如果一个事件应该在另一个事件之前发生，那么即使这些事件在现实中发生，结果也必须反映出来乱序执行（通常是为了优化程序流程）。这涉及根据并发系统中事件对的潜在因果关系对事件进行排序，尤其是异步分布式系统。它是由 Leslie Lamport 制定的。<a href="https://www.wikiwand.com/en/Happened-before#cite_note-1">[1]</a></p>
<p>The happened-before relation is formally defined as the least <a href="https://www.wikiwand.com/en/Strict_partial_order" title="Strict partial order">strict partial order</a> on events such that:<br />
happened-before 关系的正式定义为──事件最不严格的偏序，使得：</p>
<ul>
<li>If events a and b occur on the same process, a → b if the occurrence of event a preceded the occurrence of event b.<br />
如果事件 a 和 b 在同一进程上，则 a → b。事件 a 的发生先于事件 b 的发生。</li>
<li>If event a is the sending of a message and event b is the reception of the message sent in event a, a → b.<br />
如果事件 a 是消息的发送者，事件 b 是 a 发送的消息的接收者，则 a → b。</li>
</ul>
<p>If two events happen in different isolated processes (that do not exchange messages directly or indirectly via third-party processes), then the two processes are said to be concurrent, that is neither a → b nor b → a is true.<a href="https://www.wikiwand.com/en/Happened-before#cite_note-2">[2]</a><br />
如果两个事件发生在不同的隔离进程中（不直接或通过第三方进程间接交换消息），则称这两个进程是并发的，a → b 和 b → a 都不成立。<a href="https://www.wikiwand.com/en/Happened-before#cite_note-2">[2]</a></p>
<p>If there are other causal relationships between events in a given system, such as between the creation of a process and its first event, these relationships are also added to the definition. For example, in some programming languages such as Java, C, C++ or Rust, a <strong>happens-before</strong> edge exists if memory written to by statement A is visible to statement B, that is, if statement A completes its write before statement B starts its read.<br />
如果给定系统中的事件之间存在其他因果关系，例如进程的创建与此进程第一个事件之间的因果关系，这些关系也会添加到定义中。例如，在某些编程语言中，如 Java、C、C++ 或 Rust，如果语句 A 写入的内存对语句 B 可见，即如果语句 A 在语句 B 开始读取之前完成了写入，则存在 happens-before 关系。</p>
<p>The processes that make up a distributed system have no knowledge of the happened-before relation unless they use a <a href="https://www.wikiwand.com/en/Logical_clock" title="Logical clock">logical clock</a>, like a <a href="https://www.wikiwand.com/en/Lamport_clock" title="Lamport clock">Lamport clock</a> or a <a href="https://www.wikiwand.com/en/Vector_clock" title="Vector clock">vector clock</a>. This allows one to design algorithms for <a href="https://www.wikiwand.com/en/Mutual_exclusion" title="Mutual exclusion">mutual exclusion</a>, and tasks like debugging or optimising distributed systems.<br />
构成分布式系统的进程之间没有 happened-before 关系，除非它们使用逻辑时钟，如 Lamport 时钟或矢量时钟。这允许人们设计互斥算法，以及调试或优化分布式系统等任务。</p>
<hr />
<p>维基百科的定义更加明确：happened-before 表征的是一个事件应该在另一个事件之前发生。在这个例子中，我们只能肯定的是：操作 1 happened-before 操作 2，操作 3 happened-before 操作 4，其他什么都无法肯定，即使你看到了程序输出 <code>0 20</code> 也不意味着操作 4 在操作 1 之前发生或者操作 2 在操作 3 之前发生，换句话说，正是因为你使用的是 <code>Relaxed</code> 内存排序，Rust 也就放弃提供跨线程的操作顺序的保证了，而我觉得无法理解是因为我之前认为 <code>0 20</code> 根本就无法发生，但真的不会吗？来看看 GPT-4 的回答：</p>
<blockquote>
<p>在多线程环境中，使用 <code>Relaxed</code> 内存排序的原子操作不会产生跨线程的 happened-before 关系。这意味着，当线程执行操作 3 时，我们不能确定操作 2 是否已经发生。同样地，当线程执行操作 4 时，我们也不能确定操作 1 是否已经发生。</p>
<p>以下是可能导致输出 0 20 的一种情况：</p>
<ol>
<li>线程 a 执行操作 1，将 X 设置为 10。</li>
<li>线程 b 执行操作 3，加载 Y 的值。此时，线程 a 尚未执行操作 2，因此 Y 的值仍然是 0。所以，操作 3 加载的值是 0。</li>
<li>线程 a 执行操作 2，将 Y 设置为 20。</li>
<li>线程 b 执行操作 4，加载 X 的值。此时，线程 a 已经执行了操作 1，但由于没有跨线程的 happens-before 关系，线程 b 仍然可以看到 X 的旧值 0。因此，操作 4 加载的值是 0。</li>
</ol>
<p>这就是为什么输出可能是 0 20。在这种情况下，线程 b 观察到的操作顺序实际上是：操作 3、操作 4、操作 1、操作 2。这个例子说明了在使用 <code>Relaxed</code> 内存排序时，不同线程之间的操作顺序是不确定的，可能导致一些看似违反直觉的结果。</p>
</blockquote>
<p>我对这个答案不是很满意，它并未说服我，所以我接着追问：</p>
<blockquote>
<p>为什么没有跨线程的 happened-before 关系，线程 b 就可以看到 X 的旧值 0 呢？（这也的确是我最核心的疑问）</p>
</blockquote>
<blockquote>
<blockquote>
<p>当没有跨线程的 happened-before 关系时，线程 b 可以看到 X 的旧值 0，是因为内存顺序、编译器优化和处理器行为可能导致数据在不同线程之间的可见性有延迟。在我们的例子中，由于使用了 <code>Relaxed</code> 内存排序，编译器和处理器对操作的优化和重排更加自由。这可能导致线程 a 对 X 的写入操作（操作 1）在线程 b 观察到之前存在一定的延迟。以下是一些可能导致这种现象的因素：</p>
<ol>
<li>编译器优化：编译器可能会对代码进行优化，以提高执行效率。在 <code>Relaxed</code> 内存排序下，编译器可以自由地重新排序操作，只要它们在单个线程中的顺序保持不变。这种优化可能导致线程 b 在观察到线程 a 对 X 的写入操作之前存在延迟。</li>
<li>处理器缓存：现代处理器通常具有多级缓存，用于加速内存访问。当一个线程对内存位置进行写操作时，这个改动可能首先出现在处理器的缓存中，而不是立即写回到主存。在没有强制 happened-before 关系的情况下，其他线程可能在一段时间内仍然看到旧的值。</li>
<li>处理器指令重排：为了提高执行效率，处理器可能会对指令进行重排。这意味着实际执行的指令顺序可能与代码中的顺序不同。在 <code>Relaxed</code> 内存排序下，指令重排可能导致线程 b 在观察到线程 a 对 X 的写入操作之前存在延迟。</li>
</ol>
<p>因此，在没有跨线程的 happened-before 关系的情况下，线程 b 可能看到 X 的旧值 0，是由于编译器优化、处理器缓存和处理器指令重排等因素导致的内存访问延迟。这些因素使得线程之间的操作顺序和数据可见性变得不确定。</p>
</blockquote>
</blockquote>
<p>GPT-4 提供了几种可能会发生的场景，成功说服了我，因为真的有可能发生。同时我也对内存排序是如何做到的有了新的理解，这并不完全是 Rust 语言本身能决定的事情，你要考虑延迟、缓存、编译器，甚至还需要硬件、处理器的配合，那么这其中的自由度和复杂度就不是常人能全部考虑到的。</p>
<p>行文至此，再次感觉到编程的复杂，看起来简单的内存排序竟会在背后包含如此复杂的内容，不得不感叹计算机是一个整体，到了一定复杂度以后很难完全抽象出单一元素来完备地解答问题。如此发展下去，恐怕到最后也只有机器能解答机器了吧。</p>
<p>另外 AI 的确不失为一种很棒的学习工具，GPT-4 并不是一次性就给出了上述回答，它前几次的回答有错误，考虑到避免误导，我就没有把错误的对话也放上来，有的时候答案其实并不重要，如果能正确地发问，其实有些时候问题也就解决了。<br />
目前的 GPT 模型其实效果已经相当好了，但依然存在一本正经地胡说行为，因此如果想用它来学习，你最好有能分辨答案是否正确的能力，这又有些悖论了，我如果有这个能力，往往就没那么需要再问了。</p>
<p>从维基百科中可以得知 happened-before 是由 Leslie Lamport 这位分布式大牛提出的，happened-before 是为了一个更大的问题所做的铺垫，这个问题就是分布式系统中的时间。分布式系统中相当多的概念和算法都需要依靠 happened-before 这个偏序关系，说它是构成分布式世界的基石一点也不为过，详细的展开则要去读《Time, Clocks, and the Ordering of Events in a Distributed System》这篇论文才能知道了。</p>
<p>其实 happened-before 还有许多部分可以展开，不过鄙人才疏学浅，目前只掌握了这些，或许以后还会写点自己的心得体会吧，敬请期待。</p>
]]>
        </content>

        <author>
            <name>whx</name>
        </author>
    </entry>
    <entry>
        <title>从 Happened-before 说起（1）</title>
        <link rel="alternate" href="http://whx828.github.io/s3/3" type="text/html" title="从 Happened-before 说起（1）" />
        <published>2023-03-22</published>
        <updated>2023-03-22</updated>
        <id>http://whx828.github.io/s3/3</id>
        <content type="html" xml:base="http://whx828.github.io/s3/3">
            <![CDATA[<blockquote>
<p>本文大部分是背景介绍，本来想一气呵成，但发现要讲的东西有点多，遂分成了两篇来写。</p>
</blockquote>
<p><a href="https://m-ou.se/">Mara Bos</a> 关于并发主题的新书 <a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a> 最近可以免费在线阅读了，这位 Rust Library team 的 Leader 自不必多说，对 Rust 的理解（贡献）非是常人可比，而这次 Mara 博士这次的慷慨更是让手头常年拮据学生党（鄙人）直呼老铁 666！<del>耶，是官方的白嫖！</del></p>
<p>玩笑差不多了，说正事。<br />
尽管鄙人的英语是中国人水平，但为了学点 Rust，困难可以克服（感谢谷歌翻译+DeepL+ChatGPT），这本书不长，但想要读透，真正领会作者的思想，要花好多功夫。在一众翻译软件的帮助下，我简单阅读了这本书的前几章内容，其中第一个令我印象深刻的内容当属第 3 章中提到的也是我们今天的主题：Happened-before 关系。</p>
<p>要讨论 Happened-before 关系，说来话长，让我们保持耐心，先从简单的计算机历史说起。<br />
最初的计算机工作非常简单，只要把一些简单繁琐的计算任务搞定即可，在真空管和穿孔打卡的时代，程序员是把程序写到纸上，你没看错，是纸，然后在纸上穿孔，如此反复操作，直到穿成厚厚的一摞，再把这一摞交给计算机，计算机计算结果打印出来，然后程序员拿到打印结果。</p>
<blockquote>
<p>这就是最开始的 IO。</p>
</blockquote>
<p>用今天的眼光看那时的程序员也太不容易了，纸上编程确实有助于学习编码和思考代码逻辑，但如果真要把干活的程序写在纸上再去穿孔才能执行，这种繁琐、浪费是现在的程序员所无法想象的（谁愿意天天穿孔），你可能会问：如果我就运行自己的程序行不行，答案是不行！在当时计算机的资源是相当昂贵的，没有那么多机器让你一个人玩，就像买东西太贵选择拼单一样，你写程序也要和人拼计算机，所谓批处理就是这么一回事，名字起得挺高深，实际上背后一把辛酸泪。</p>
<p>这样的 IO 用脚趾头想都能想到肯定会和 CPU 的速度存在巨大差异，CPU 的计算时间非常少而等待 IO 结束的时间却很多。所以为了 <del>让 CPU 更累</del> 更合理地利用 CPU 计算资源，我们就得想个办法，看能不能「偷」点时间出来。后来不知道哪位天使大哥/大姐想到了一个鬼点子：我们可以把内存划分为多个部分（日子宽裕了，内存也比以前大了，可以让更多程序用了），不同的程序可以使用各自的内存部分互不干涉，这些单独的程序就是所谓的进程。然后我们给 CPU 再加上一个超能力：跨进程切换执行。这样就有戏法可以玩了：当某个进程进行磁盘 IO 的时候，CPU 就可以切换到另外一个进程执行（闲着也是闲着，不如干点别的活），这样就 <del>让 CPU 更累</del> 偷出了本来可以摸鱼（等待 IO）的时间来干活（运行其他进程），我们的目的达到了！（能力越大，责任就越大嘛~）</p>
<p>怎么给 CPU 加上跨进程切换执行的超能力呢？请看三板斧：</p>
<ul>
<li>CPU 时间片：现在我们有很多进程，所以对于每个进程如何执行，需要有个规定──每一次切换进程后，CPU 只会工作一段时间，然后又切换到另外一个进程，再执行一段时间。我们把 CPU 切换进程的这个时间段叫做“时间片”。</li>
<li>程序计数器：CPU 经过一圈切换后还会切换回最开始的进程继续执行（对每个进程都是如此），所以它需要知道进程已经执行到了哪一步才好接着执行，程序计数器应运而生，它会记住进程执行到的位置。有了这个就可以继续执行了。</li>
<li>栈指针：程序计数器解决了记忆程序（代码）执行到的位置，但是每个进程还持有操作系统分配给它的内存资源，这玩意对每个进程是独立的，因此也需要记录，所以我们用栈指针来记录操作系统给它的内存资源地址。</li>
</ul>
<p>这三板斧下去，CPU 再也不好摸鱼了，比起以前，那效率是高多了，但是人类对于极致的追求是无止境的，大家慢慢发现切换进程这个操作本身居然挺费时间，如果每个进程都有很多 IO，那么 CPU 的时间都被切换进程浪费掉了，然后还什么都没做，这不是又让 CPU 闲着了吗？不行，必须要解决！</p>
<blockquote>
<p>这只是一个缺点，相关的缺点还有很多，不一一列举了。</p>
</blockquote>
<p>进程切换成本这么高，一部分的原因是进程太「重」了，每切换一次上面的三板斧都得顾及到，那么让它变得小一点不就好了吗？这就是线程：我们让一个进程创建很多个线程，然后让线程来做以前进程的工作，现在 CPU 会在线程而不是进程之间来回切换，由于线程更小，时间片也分得更小，以至于多个线程之间切换执行成本也小了，同时 CPU 等待 IO 的几率也更加小了。一举多得。</p>
<blockquote>
<p>线程版本的三板斧：</p>
<ul>
<li>程序计数器，表示当前线程执行指令的位置。</li>
<li>保存变量的寄存器。</li>
<li>栈。每个线程的栈记录了函数调用的记录，并反映了当前线程的执行点。</li>
</ul>
</blockquote>
<p>技术领域有一句名言：没有银弹。意思是不管什么问题，没有万能解决方案。多线程也不是没缺点，对程序员来说最直观的感受就是：多线程编程更难。为什么？因为在多线程编程的场景下，你会经常遇到「多个线程同时读取和修改同一个变量」的问题，而在 Rust 中，我们认为“这通常会导致未定义的行为（UB）”。</p>
<p>为什么“多个线程同时读取和修改同一个变量”会是个问题？这不是效率更高了吗？请看下面的伪代码：</p>
<pre style="background-color:#fafafa;">
<span style="color:#61676c;">data_race() {
</span><span style="color:#61676c;">  global x = 0
</span><span style="color:#61676c;">  
</span><span style="color:#61676c;">  thread1 = thread {
</span><span style="color:#61676c;">    for i in 0..100 {
</span><span style="color:#61676c;">      x += 1;
</span><span style="color:#61676c;">    }
</span><span style="color:#61676c;">  };
</span><span style="color:#61676c;">
</span><span style="color:#61676c;">  thread2 = thread {
</span><span style="color:#61676c;">    for i in 0..100 {
</span><span style="color:#61676c;">      x += 1;
</span><span style="color:#61676c;">    }
</span><span style="color:#61676c;">  };
</span><span style="color:#61676c;">
</span><span style="color:#61676c;">  t1 = thread1.spawn();
</span><span style="color:#61676c;">  t2 = thread2.spawn();
</span><span style="color:#61676c;">
</span><span style="color:#61676c;">  t1.join();
</span><span style="color:#61676c;">  t2.join();
</span><span style="color:#61676c;">
</span><span style="color:#61676c;">  return x;
</span><span style="color:#61676c;">}
</span></pre>
<blockquote>
<p>之所以写伪代码是因为用 Rust 想写个有问题的程序着实不容易。</p>
</blockquote>
<p>伪代码说明（虽然我希望这是不言自明的）：</p>
<ul>
<li><code>global x = 0</code> 表示 <code>x</code> 是个全局变量，每个线程都能看到并修改它的值</li>
<li><code>thread1 =  thread { for i in 0..100 { x += 1; } };</code> 表示 <code>thread1</code> 对 <code>x</code> 进行 100 次加 1 操作，这是 <code>thread1</code> 的定义</li>
<li><code>t1 = thread1.spawn();</code> 则是启动 <code>thread1</code>，<code>thread1</code> 自此开始执行</li>
<li><code>thread1.join();</code> 表示当前线程（主线程）将一直等待 <code>thread1</code> 执行结束</li>
<li><code>thread2</code> 上述一切同理</li>
</ul>
<p>请猜想下，这段程序执行到 <code>return x;</code> 时，<code>x</code> 的值会是多少？ </p>
<p>答案是：只有天知道，理论上在 100-200 之间的任何整数值都有可能。</p>
<p>你可能会问：<code>x</code> 不是 <code>200</code> 吗？<br />
<code>x</code> 不一定会是 <code>200</code>，这就是多线程编程的吊诡之处，很反直觉。</p>
<blockquote>
<p>更反直觉的还在后面。</p>
</blockquote>
<p>试想下面的过程：<br />
（1）CPU 时间片先分给 <code>thread1</code> 执行，假设代表 <code>x</code> 这个变量的寄存器在 <code>thread1</code> 中执行累加到了 50，此时恰巧时间片用完了，而存放在寄存器中的值 50 还没来及写入实际的物理内存。<br />
（2）因为时间片用完了，CPU 现在分配给 <code>thread2</code>，由于 <code>thread1</code> 算出来的值并没有写回内存，所以实际上此时 <code>thread2</code> 还是从 <code>x = 0</code> 开始进行加 1 操作，这次我们假设分给它的时间片够进行 60 次加 1 操作，之后 <code>thread2</code> 将得到的 <code>x = 60</code> 写入实际的物理内存。<br />
（3）时间片再度分配给 <code>thread1</code>，<code>thread1</code> 开始执行它在上一个时间片结束时没有执行完的工作，将 <code>x = 50</code> 写入实际的物理内存，计算机严格按照代码执行指令，但此时问题出现：<code>thread1</code> 计算并写入的 <code>x = 50</code> 会把 <code>thread2</code> 计算并写入的 <code>x = 60</code> 覆盖掉。而每次执行程序，上述情况的发生总不会完全一致，比如时间片的大小就不是能完全确定的，相当于每次都有微调，这就是多次执行相同的代码得到的结果却完全不一致的原因。</p>
<blockquote>
<p>其实真实的过程比这复杂得多，这里进行了简化以方便讨论概念。</p>
</blockquote>
<p>如何解决这样的问题？先来看问题出在哪里。我们可以发现上面程序过程中的关键点是：每个线程的 <strong>计算 <code>x</code> 的值</strong> 和 <strong>把算好的值存入物理内存</strong> 这两个操作之间是 <strong>不连续的</strong>，这样就给了其他线程进来搞破坏的可趁之机。<br />
如果在单个线程中，计算值和把算好的值存入内存这两个操作连续进行是很自然的，自然到你根本不会意识到它们还可以不连续，这是你编程时的默认心智模型，如果这一条都不成立大家也就不用编码了。</p>
<blockquote>
<p>其实这里面还有指令重排的事，别以为你「看到」的就是「真相」。</p>
</blockquote>
<p>但是在多线程环境中，这就成为了问题，为了灵活和性能，多线程编程的自由度更高。如果多线程编程要强行规定线程间的执行顺序、线程内的指令执行顺序，那样还有意义吗？还不如继续优化多进程。</p>
<p>好，我们现在遇到了一个“既要…还要…”的问题：我们既要留住多线程的灵活，又要让它在某些时候不那么灵活，有没有两全法呢？有，原子操作！</p>
<p>原子操作是什么呢？我认为最通俗易懂的说法是：要么不做，要么全做。不过我的总结不够规范，咱们还是来看专业人士（Mara Bos 博士）是怎么表述这个概念的：</p>
<blockquote>
<p>The word atomic comes from the Greek word ἄτομος, meaning indivisible, something that cannot be cut into smaller pieces. In computer science, it is used to describe an operation that is indivisible: it is either fully completed, or it didn’t happen yet.<br />
原子这个词来自希腊语 ἄτομος，意思是不可分割的，不能被切割成更小的部分。在计算机科学中，它被用来描述一个不可分割的操作：它要么完全完成，要么还没有发生。<br />
However, atomic operations do allow for different threads to safely read and modify the same variable. Since such an operation is indivisible, it either happens completely before or completely after another operation, avoiding undefined behavior.<br />
原子操作允许不同的线程安全地读取和修改同一个变量。由于原子操作是不可分割的，它要么完全发生在另一个操作之前，要么完全发生在另一个操作之后，这样就避免了 UB。</p>
<p>Atomic operations are the main building block for anything involving multiple threads. All the other concurrency primitives, such as mutexes and condition variables, are implemented using atomic operations.<br />
原子操作是涉及多线程的任何事物的主要构建块。所有其他并发原语，例如互斥量和条件变量，都是使用原子操作实现的。<br />
In Rust, atomic operations are available as methods on the standard atomic types that live in <code>std::sync::atomic</code>. They all have names starting with <code>Atomic</code>, such as <code>AtomicI32</code> or <code>AtomicUsize</code>. Which ones are available depends on the hardware architecture and sometimes operating system, but almost all platforms provide at least all atomic types up to the size of a pointer.<br />
在 Rust 中，原子操作可以作为存在于 <code>std::sync::atomic</code> 中的标准原子类型的方法。它们的名称都以 <code>Atomic</code> 开头，例如 <code>AtomicI32</code> 或 <code>AtomicUsize</code>。哪些可用取决于硬件架构，有时取决于操作系统，但几乎所有平台都至少提供所有原子类型，最大为指针大小。<br />
Unlike most types, they allow modification through a shared reference (e.g., <code>&amp;AtomicU8</code>). This is possible thanks to interior mutability, as discussed in “Interior Mutability” in Chapter 1.<br />
与大多数类型不同，它们允许通过共享引用进行修改（例如 <code>&amp;AtomicU8</code>）。这要归功于内部可变性，正如第 1 章“内部可变性”中所讨论的那样。</p>
</blockquote>
<p>我们可以看到“原子操作是不可分割的”，放在我们的例子中这也就意味着我们可以通过原子操作，让线程的 <strong>计算 <code>x</code> 的值</strong> 和 <strong>把算好的值存入物理内存</strong> 之间是 <strong>不可分割的</strong>，那么也就不会出现前文中所述的错误，<code>x</code> 就会是 <code>200</code>。 </p>
<p>Rust 是一门标榜“安全”的语言，既然多线程编程中会有“不安全”的场景出现，那么 Rust 肯定要考虑如何解决，不过相比 The book 中其他主题的 Rust 安全特色（所有权、借用检查等），我读到 Rust Atomics and Locks 后面只觉得在多线程编程方面，Rust 还是很明显地抄了不少别人（C++）的东西，例如下面 Mara Bos 博士话锋一转，开始讨论起了另一个概念：</p>
<blockquote>
<p>But, before we can dive into the different atomic operations, we briefly need to touch upon a concept called memory ordering:<br />
但是，在我们深入研究不同的原子操作之前，我们需要简单地谈谈一个叫做内存排序的概念：<br />
Every atomic operation takes an argument of type <code>std::sync::atomic::Ordering</code>, which determines what guarantees we get about the relative ordering of operations. The simplest variant with the fewest guarantees is <code>Relaxed</code>. <code>Relaxed</code> still guarantees consistency on a single atomic variable, but does not promise anything about the relative order of operations between different variables.<br />
每个原子操作都有一个类型为 <code>std::sync::atomic::Ordering</code> 的参数，它决定了我们对操作的相对顺序有什么「保证」。而「保证」最少的、最简单的变体是 <code>Relaxed</code>。<code>Relaxed</code> 仍然保证单个原子变量的一致性，但不保证不同变量之间的相对操作顺序。<br />
What this means is that two threads might see operations on different variables happen in a different order. For example, if one thread writes to one variable first and then to a second variable very quickly afterwards, another thread might see that happen in the opposite order.<br />
这意味着两个线程可能会看到对不同变量的操作以不同的顺序发生。例如，如果一个线程首先写入一个变量，然后很快写入第二个变量，则另一个线程可能会看到以相反顺序发生的情况。</p>
</blockquote>
<p>我之前说有更反直觉的东西，这不现在看到了？为什么第二个线程可能看到以相反顺序发生的情况？</p>
<blockquote>
<p>Processors and compilers perform all sorts of tricks to make your programs run as fast as possible. A processor might determine that two particular consecutive instructions in your program will not affect each other, and execute them out of order, if that is faster, for example. While one instruction is briefly blocked on fetching some data from main memory, several of the following instructions might be executed and finished before the first instruction finishes, as long as that wouldn’t change the behavior of your program. Similarly, a compiler might decide to reorder or rewrite parts of your program if it has reason to believe it might result in faster execution. But, again, only if that wouldn’t change the behavior of your program.<br />
处理器和编译器执行各种技巧以使您的程序运行得尽可能快。处理器可能会确定您程序中的两个特定的连续指令不会相互影响，并乱序执行它们（例如，如果这样更快的话）。虽然一条指令在从主存中获取一些数据时被短暂阻塞，但在第一条指令完成之前，可能会执行并完成以下几条指令，只要这不会改变程序的行为。同样，如果编译器有理由相信它可能会导致更快的执行，它可能会决定重新排序或重写程序的某些部分。但是，同样，前提是这不会改变您的程序的行为。</p>
<p>Let’s take a look at the following function as an example:<br />
让我们以下面的函数为例：</p>
</blockquote>
<pre style="background-color:#fafafa;">
<span style="color:#fa6e32;">fn </span><span style="color:#f29718;">f</span><span style="color:#61676c;">(</span><span style="color:#ff8f40;">a</span><span style="color:#61676ccc;">: </span><span style="color:#ed9366;">&amp;</span><span style="color:#fa6e32;">mut i32</span><span style="color:#61676c;">, </span><span style="color:#ff8f40;">b</span><span style="color:#61676ccc;">: </span><span style="color:#ed9366;">&amp;</span><span style="color:#fa6e32;">mut i32</span><span style="color:#61676c;">) {
</span><span style="color:#61676c;">    </span><span style="color:#ed9366;">*</span><span style="color:#61676c;">a </span><span style="color:#ed9366;">+= </span><span style="color:#ff8f40;">1</span><span style="color:#61676ccc;">;
</span><span style="color:#61676c;">    </span><span style="color:#ed9366;">*</span><span style="color:#61676c;">b </span><span style="color:#ed9366;">+= </span><span style="color:#ff8f40;">1</span><span style="color:#61676ccc;">;
</span><span style="color:#61676c;">    </span><span style="color:#ed9366;">*</span><span style="color:#61676c;">a </span><span style="color:#ed9366;">+= </span><span style="color:#ff8f40;">1</span><span style="color:#61676ccc;">;
</span><span style="color:#61676c;">}
</span></pre>
<blockquote>
<p>Here, the compiler will most certainly understand that the order of these operations does not matter, since nothing happens between these three addition operations that depends on the value of <code>*a</code> or <code>*b</code>. (Assuming overflow checking is disabled.) Because of that, it might reorder the second and third operations, and then merge the first two into a single addition:<br />
在这里，编译器肯定会理解这些操作的顺序无关紧要，因为这三个取决于 <code>*a</code> 或 <code>*b</code> 的值的加法操作之间没有任何关联。（假设溢出检查被禁用）因此，它可能会重新排序第二个和第三个操作，然后将前两个合并为一个加法：</p>
</blockquote>
<pre style="background-color:#fafafa;">
<span style="color:#fa6e32;">fn </span><span style="color:#f29718;">f</span><span style="color:#61676c;">(</span><span style="color:#ff8f40;">a</span><span style="color:#61676ccc;">: </span><span style="color:#ed9366;">&amp;</span><span style="color:#fa6e32;">mut i32</span><span style="color:#61676c;">, </span><span style="color:#ff8f40;">b</span><span style="color:#61676ccc;">: </span><span style="color:#ed9366;">&amp;</span><span style="color:#fa6e32;">mut i32</span><span style="color:#61676c;">) {
</span><span style="color:#61676c;">    </span><span style="color:#ed9366;">*</span><span style="color:#61676c;">a </span><span style="color:#ed9366;">+= </span><span style="color:#ff8f40;">2</span><span style="color:#61676ccc;">;
</span><span style="color:#61676c;">    </span><span style="color:#ed9366;">*</span><span style="color:#61676c;">b </span><span style="color:#ed9366;">+= </span><span style="color:#ff8f40;">1</span><span style="color:#61676ccc;">;
</span><span style="color:#61676c;">}
</span></pre>
<blockquote>
<p>Later, while executing this function of the optimized compiled program, a processor might for a variety of reasons end up executing the second addition before the first addition, possibly because <code>*b</code> was available in a cache, while <code>*a</code> had to be fetched from the main memory.<br />
稍后，在执行优化编译程序的这个函数时，处理器可能由于各种原因在第一次加法之前结束执行第二次加法，这可能是因为 <code>*b</code> 在缓存中可用，而 <code>*a</code> 必须从主存提取。<br />
Regardless of these optimizations, the result stays the same: <code>*a</code> is incremented by two and <code>*b</code> is incremented by one. The order in which they were incremented is entirely invisible to the rest of your program.<br />
不管这些优化如何，结果都保持不变：<code>*a</code> 增加 2，<code>*b</code> 增加 1。它们递增的顺序对于程序的其余部分是完全不可见的。</p>
<p>The logic for verifying that a specific reordering or other optimization won’t affect the behavior of your program does not take other threads into account. In our example above, that’s perfectly fine, as the unique references (&amp;mut i32) guarantee that nothing else can possibly access the values, making other threads irrelevant. The only situation where this is a problem is when mutating data that’s shared between threads. Or, in other words, when working with atomics. This is why we have to explicitly tell the compiler and processor what they can and can’t do with our atomic operations, since their usual logic ignores interactions between threads and might allow for optimizations that do change the result of your program.<br />
验证特定重新排序或其他优化不会影响程序行为的逻辑不会考虑其他线程。在我们上面的示例中，这完全没问题，因为独占引用 (<code>&amp;mut i32</code>) 保证没有其他任何东西可以访问这些值，从而使其他线程无关紧要。唯一会出现问题的情况是在改变线程之间共享的数据时。或者，换句话说，在使用原子时。这就是为什么我们必须明确地告诉编译器和处理器它们可以用我们的原子操作做什么和不能做什么，因为它们通常的逻辑会忽略线程之间的交互，并且可能允许进行确实会改变程序结果的优化。<br />
The interesting question is how we tell them. If we wanted to precisely spell out exactly what is and isn’t acceptable, concurrent programming might become exceedingly verbose and error prone, and maybe even architecture-specific:<br />
有趣的问题是我们如何告诉他们。如果我们想准确地说明什么是可接受的，什么是不可接受的，并发编程可能会变得非常冗长和容易出错，甚至可能是特定于体系结构的：</p>
</blockquote>
<pre style="background-color:#fafafa;">
<span style="color:#fa6e32;">let</span><span style="color:#61676c;"> x </span><span style="color:#ed9366;">=</span><span style="color:#61676c;"> a</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">fetch_add</span><span style="color:#61676c;">(</span><span style="color:#ff8f40;">1</span><span style="color:#61676ccc;">,
</span><span style="color:#61676c;">    Dear compiler and processor</span><span style="color:#61676ccc;">,
</span><span style="color:#61676c;">    Feel free to reorder this with operations on b</span><span style="color:#61676ccc;">,
</span><span style="color:#61676c;">    but </span><span style="color:#fa6e32;">if</span><span style="color:#61676c;"> there</span><span style="color:#fa6e32;">&#39;s</span><span style="color:#61676c;"> another thread concurrently executing f</span><span style="color:#61676ccc;">,
</span><span style="color:#61676c;">    please don</span><span style="color:#fa6e32;">&#39;t</span><span style="color:#61676c;"> reorder this with operations on c</span><span style="color:#ed9366;">!
</span><span style="color:#61676c;">    Also</span><span style="color:#61676ccc;">,</span><span style="color:#61676c;"> processor</span><span style="color:#61676ccc;">,</span><span style="color:#61676c;"> don</span><span style="color:#fa6e32;">&#39;t</span><span style="color:#61676c;"> forget to flush your store buffer</span><span style="color:#ed9366;">!
</span><span style="color:#61676c;">    If b is zero</span><span style="color:#61676ccc;">,</span><span style="color:#61676c;"> though</span><span style="color:#61676ccc;">,</span><span style="color:#61676c;"> it doesn</span><span style="color:#fa6e32;">&#39;t</span><span style="color:#61676c;"> matter</span><span style="color:#ed9366;">.
</span><span style="color:#61676c;">    In that case</span><span style="color:#61676ccc;">,</span><span style="color:#61676c;"> feel free to </span><span style="color:#f51818;">do</span><span style="color:#61676c;"> whatever is fastest</span><span style="color:#ed9366;">.
</span><span style="color:#61676c;">    Thanks</span><span style="color:#ed9366;">~ &lt;</span><span style="color:#ff8f40;">3
</span><span style="color:#61676c;">)</span><span style="color:#61676ccc;">;
</span></pre>
<blockquote>
<p>Instead, we can only pick from a small set of options, represented by the <code>std::sync::atomic::Ordering</code> enum, which every atomic operation takes as an argument. The set of available options is very limited, but has been carefully picked to fit most use cases well. The orderings are very abstract and do not directly reflect the actual compiler and processor mechanisms involved, such as instruction reordering. This makes it possible for your concurrent code to be architecture-independent and future-proof. It allows for verification without knowing the details of every single current and future processor and compiler version.<br />
相反，我们只能从一小组选项中选择，由 <code>std::sync::atomic::Ordering</code> 枚举表示，每个原子操作都将其作为参数。可用选项集非常有限，但经过精心挑选以适合大多数用例。排序非常抽象，并不直接反映所涉及的实际编译器和处理器机制，例如指令重新排序。这使您的并发代码可以独立于体系结构且面向未来。它允许在不知道每个当前和未来处理器和编译器版本的详细信息的情况下进行验证。</p>
<p>The available orderings in Rust are:<br />
Rust 中可用的排序是：</p>
<ul>
<li>Relaxed ordering: Ordering::Relaxed</li>
<li>Release and acquire ordering: Ordering::{Release, Acquire, AcqRel}</li>
<li>Sequentially consistent ordering: Ordering::SeqCst</li>
</ul>
<p>In C++, there is also something called consume ordering, which has been purposely omitted from Rust, but is nonetheless interesting to discuss as well.<br />
在 C++ 中，还有一种叫做 consume ordering 的东西，它在 Rust 中被故意省略了，但讨论起来也很有趣。</p>
</blockquote>
<p>在这一大段里我们来捞点干的，大意是编译器会优化代码，导致指令执行顺序和代码表示的顺序不一定一致，而这一点在多线程环境下被放大了。不管是否有指令重排，第一个线程实际上并不关心，因为不会影响它的执行结果，而假如发生了指令重排，使第一个线程真实的执行顺序变得和原来相反，那么第二个线程就看到了相反顺序的发生情况，如果第二个线程的操作对第一个线程的操作顺序有所依赖，这就会出现问题。所以在某些特殊场合，我们需要有能力对代码/指令的执行顺序有所限制，如果你不想做上面 Mara 博士举例的“面向协议编程”，内存排序则是你的救星。</p>
<blockquote>
<p>The different memory ordering options have a strict formal definition to make sure we know exactly what we’re allowed to assume, and for compiler writers to know exactly what guarantees they need to provide to us. To decouple this from the details of specific processor architectures, memory ordering is defined in terms of an abstract <em>memory model</em>.<br />
不同的内存排序选项有一个严格的正式定义，以确保我们确切地知道我们被允许假设什么，并让编译器编写者确切地知道他们需要为我们提供什么保证。为了将其与特定处理器架构的细节分离，内存排序是根据抽象内存模型定义的。</p>
</blockquote>
<blockquote>
<p>Rust’s memory model, which is mostly copied from C++, doesn’t match any existing processor architecture, but instead is an abstract model with a strict set of rules that attempt to represent the greatest common denominator of all current and future architectures, while also giving the compiler enough freedom to make useful assumptions while analyzing and optimizing programs.<br />
Rust 的内存模型，主要是从 C++ 复制而来，不匹配任何现有的处理器架构，而是一个具有一组严格规则的抽象模型，试图代表所有当前和未来架构的最大公分母，同时也给出编译器有足够的自由在分析和优化程序时做出有用的假设。</p>
</blockquote>
<blockquote>
<p>We’ve already seen a part of the memory model in action in <a href="https://marabos.nl/atomics/basics.html#borrowing-and-races">“Borrowing and Data Races” in Chapter 1</a>, where we talked about how data races result in undefined behavior. Rust’s memory model allows for concurrent atomic stores, but considers concurrent non-atomic stores to the same variable to be a data race, resulting in undefined behavior.<br />
我们已经在第 1 章的“借用和数据竞争”中看到了内存模型的一部分，我们在其中讨论了数据竞争如何导致未定义的行为。Rust 的内存模型允许并发<strong>原子存储</strong>，但将对同一变量的并发<strong>非原子存储</strong>视为数据竞争──导致未定义的行为。</p>
</blockquote>
<p>计算机的难题 99% 是靠分层解决的，Rust 的内存模型也不例外，这里借鉴了 C++，或者说是编译器前后端/虚拟机的经验，不对某一具体处理器架构而是在这中间又加了一个抽象层，这样就能最大程度地保证灵活，除了多了一层翻译会有一点性能上的权衡以外没啥缺点。</p>
<p>激动，终于要谈到今天的主题──Happened-before 关系了，接着读：</p>
<blockquote>
<p>The memory model defines the order in which operations happen in terms of <em>happens-before relationships</em>. This means that as an abstract model, it doesn’t talk about machine instructions, caches, buffers, timing, instruction reordering, compiler optimizations, and so on, but instead only defines situations where one thing is guaranteed to happen before another thing, and leaves the order of everything else undefined.<br />
内存模型定义了操作发生的顺序，即 happens-before 关系。这意味着，作为一个抽象的模型，它不谈论机器指令、缓存、缓冲区、时间、指令重排、编译器优化等等，只定义了一件事在另一件事之前发生的情况，而对其他事情的顺序没有定义。</p>
</blockquote>
<blockquote>
<p>The basic happens-before rule is that everything that happens within the same thread happens in order. If a thread is executing <code>f(); g();</code>, then <code>f()</code> <em>happens-before</em> <code>g()</code>.<br />
基本的 happens-before 规则是同一线程内发生的所有事情都按顺序发生。如果线程正在执行 <code>f(); g();</code>，那么 <code>f()</code> happens-before <code>g()</code>。</p>
</blockquote>
<p>这里我补充一些内容：</p>
<ol start="0">
<li>Mara 博士原文是 happens-before，这是编程语言的用法，但我更想讨论的是 happened-before 事件间的关系，故引述原文的地方我不做改动，但在我自己叙述的时候使用后者</li>
<li>当 A 操作 <strong>happened-before</strong> B 操作的时候，操作 A 先于操作 B 执行，且 A 操作的结果对 B 来说可见。每个线程都可以执行不同的任务，但是当它们之间进行一些交互时，例如读写共享内存或发送和接收消息时，必须遵守一些规则。这些规则确保了在一个线程中发生的操作在另一个线程中变得可见之前已经完成。也就是说，在一个线程中发生的操作 happened-before 了在另一个线程中看到该操作</li>
<li><strong>happened-before</strong> 包含两种情况：</li>
</ol>
<ul>
<li>对于同一线程内的 happened-before，其等同于 sequenced-before（A <em>sequenced-before</em> B → 代表 A 的求值会先完成，之后才进行对 B 的求值）</li>
<li>对于不同线程内的 happened-before，其等同于 inter-thread happened before（A <em>inter-thread happened before</em> B → 如果操作 A happened-before 操作 B，则可以保证线程 1 中的操作 A 的执行对线程 2 中的操作 B 的执行是可见的，也就是说，操作 A 执行后对共享状态所做的修改对线程 2 可见）</li>
</ul>
<blockquote>
<p>Between threads, however, happens-before relationships only occur in a few specific cases, such as when spawning and joining a thread, unlocking and locking a mutex, and through atomic operations that use non-relaxed memory ordering. <code>Relaxed</code> memory ordering is the most basic (and most performant) memory ordering that, by itself, never results in any cross-thread happens-before relationships.<br />
然而，在线程之间，happens-before 关系只发生在少数特定情况下，例如 spawn 线程和 join 线程、解锁和锁定互斥锁以及使用非 <code>Relaxed</code> 内存排序的原子操作。<code>Relaxed</code> 内存排序是最基本（也是最高效）的内存排序，它本身不会导致任何跨线程的 happens-before 关系。</p>
<p>To explore what that means, let’s take a look at the following example where we assume <code>a</code> and <code>b</code> are concurrently executed by different threads:<br />
为了探究这意味着什么，让我们看一下下面的示例，其中我们假设 <code>a</code> 和 <code>b</code> 由不同的线程同时执行：</p>
</blockquote>
<pre style="background-color:#fafafa;">
<span style="color:#fa6e32;">static</span><span style="color:#61676c;"> X</span><span style="color:#61676ccc;">:</span><span style="color:#61676c;"> AtomicI32 </span><span style="color:#ed9366;">= </span><span style="color:#61676c;">AtomicI32</span><span style="color:#ed9366;">::</span><span style="color:#61676c;">new(</span><span style="color:#ff8f40;">0</span><span style="color:#61676c;">)</span><span style="color:#61676ccc;">;
</span><span style="color:#fa6e32;">static</span><span style="color:#61676c;"> Y</span><span style="color:#61676ccc;">:</span><span style="color:#61676c;"> AtomicI32 </span><span style="color:#ed9366;">= </span><span style="color:#61676c;">AtomicI32</span><span style="color:#ed9366;">::</span><span style="color:#61676c;">new(</span><span style="color:#ff8f40;">0</span><span style="color:#61676c;">)</span><span style="color:#61676ccc;">;
</span><span style="color:#61676c;">
</span><span style="color:#fa6e32;">fn </span><span style="color:#f29718;">a</span><span style="color:#61676c;">() {
</span><span style="color:#61676c;">    X</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">store</span><span style="color:#61676c;">(</span><span style="color:#ff8f40;">10</span><span style="color:#61676ccc;">,</span><span style="color:#61676c;"> Relaxed)</span><span style="color:#61676ccc;">;    </span><span style="font-style:italic;color:#abb0b6;">// 1
</span><span style="color:#61676c;">    Y</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">store</span><span style="color:#61676c;">(</span><span style="color:#ff8f40;">20</span><span style="color:#61676ccc;">,</span><span style="color:#61676c;"> Relaxed)</span><span style="color:#61676ccc;">;    </span><span style="font-style:italic;color:#abb0b6;">// 2
</span><span style="color:#61676c;">}
</span><span style="color:#61676c;">
</span><span style="color:#fa6e32;">fn </span><span style="color:#f29718;">b</span><span style="color:#61676c;">() {
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">let</span><span style="color:#61676c;"> y </span><span style="color:#ed9366;">=</span><span style="color:#61676c;"> Y</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">load</span><span style="color:#61676c;">(Relaxed)</span><span style="color:#61676ccc;">; </span><span style="font-style:italic;color:#abb0b6;">// 3
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">let</span><span style="color:#61676c;"> x </span><span style="color:#ed9366;">=</span><span style="color:#61676c;"> X</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">load</span><span style="color:#61676c;">(Relaxed)</span><span style="color:#61676ccc;">; </span><span style="font-style:italic;color:#abb0b6;">// 4
</span><span style="color:#61676c;">    </span><span style="color:#f07171;">println!</span><span style="color:#61676c;">(</span><span style="color:#86b300;">&quot;</span><span style="color:#ff8f40;">{x} {y}</span><span style="color:#86b300;">&quot;</span><span style="color:#61676c;">)</span><span style="color:#61676ccc;">;
</span><span style="color:#61676c;">}
</span></pre>
<blockquote>
<p>As mentioned above, the basic happens-before rule is that everything that happens within the same thread happens in order. In this case: 1 happens-before 2, and 3 happens-before 4, as shown in <a href="https://marabos.nl/atomics/memory-ordering.html#happens-before-diagram-load-store">Figure 3-1</a>. Since we use relaxed memory ordering, there are no other happens-before relationships in our example.<br />
如上所述，基本的 happens-before 规则是同一线程内发生的所有事情都按顺序发生。在这种情况下：1 happens-before 2，3 happens-before 4，如图 3-1 所示。由于我们使用 <code>Relaxed</code> 内存排序，因此在我们的示例中没有其他 happens-before 关系。</p>
</blockquote>
<p><img src="https://marabos.nl/atomics/images/raal_0301.png" alt="" loading="lazy"></p>
<p>Figure 3-1. The happens-before relationships between atomic operations in the example code.<br />
图 3-1 示例代码中原子操作之间的 happens-before 关系。</p>
<blockquote>
<p>If either of <code>a</code> or <code>b</code> completes before the other starts, the output will be <code>0 0</code> or <code>10 20</code>. If <code>a</code> and <code>b</code> run concurrently, it’s easy to see how the output can be <code>10 0</code>. One way this can happen is if the operations run in this order: 3 1 2 4.<br />
如果 <code>a</code> 或 <code>b</code> 中的任何一个在另一个开始之前完成，则输出将为 <code>0 0</code> 或 <code>10 20</code>。如果 <code>a</code> 和 <code>b</code> 同时运行，很容易看出输出是 <code>10 0</code>。发生这种情况的一种方式是操作按以下顺序运行：3 1 2 4。</p>
</blockquote>
<blockquote>
<p>More interestingly, the output can also be <code>0 20</code>, even though there is no possible globally consistent order of the four operations that would result in this outcome. When 3 is executed, there is no happens-before relationship with 2, which means it could load either 0 or 20. When 4 is executed, there is no happens-before relationship with 1, which means it could load either 0 or 10. Given this, the output <code>0 20</code> is a valid outcome.<br />
更有趣的是，输出也可以是 <code>0 20</code>，<strong>即使没有可能导致此结果的四个操作的全局一致顺序</strong>。当 3 执行时，与 2 没有 happens-before 关系，也就是说它可以加载 0 或 20。当 4 执行时，与 1 没有 happens-before 关系，这意味着它可以加载 0 或 10。鉴于此，输出 <code>0 20</code> 是一个有效的结果。</p>
</blockquote>
<blockquote>
<p>The important and counter-intuitive thing to understand is that operation 3 loading the value 20 does <em>not</em> result in a happens-before relationship with 2, even though that value is the one stored by 2. Our intuitive understanding of the concept of “before” breaks down when things don’t necessarily happen in a globally consistent order, such as when instruction reordering is involved.<br />
需要理解的重要且违反直觉的事情是，操作 3 加载值 20 不会导致与操作 2 为 happens-before 关系，即使该值是由操作 2 存储的。当事情不一定以全局一致顺序发生时，我们对“before”概念的直觉理解就会崩溃，例如当涉及<strong>指令重排</strong>时。<br />
A more practical and intuitive, but less formal, understanding is that from the perspective of the thread executing <code>b</code>, operations 1 and 2 might appear to happen in the opposite order.<br />
一种更实用、更直观但不太正式的理解是，从执行 <code>b</code> 的线程的角度来看，操作 1 和 2 的发生顺序可能相反。</p>
</blockquote>
<p>迷糊了吧，我也迷糊了，我始终无法理解 <code>0 20</code> 是怎么成为一个有效结果的。首先输出 <code>0</code>，这意味着操作 4 在操作 1 之前发生；输出 <code>20</code> 则意味着操作 2 在操作 3 之前发生，而最关键的“基本的 happened-before 规则是同一线程内发生的所有事情都按顺序发生”，那么也就是说操作 3 在操作 4 之前发生，操作 1 在操作 2 之前发生，我是没有想得到是什么样的全局顺序能够满足这些要求，无论怎么想都有矛盾，Mara 博士也说这个例子中并没有能导致该结果的四个操作的全局一致顺序，所以如果还在这个方向思考，肯定是难以得到简单直观解释的。</p>
<p>让我卖个关子（其实已有伏笔），欲知后事如何，且听下回分解。</p>
]]>
        </content>

        <author>
            <name>whx</name>
        </author>
    </entry>
    <entry>
        <title>AI 来了</title>
        <link rel="alternate" href="http://whx828.github.io/s3/2" type="text/html" title="AI 来了" />
        <published>2023-03-17</published>
        <updated>2023-03-17</updated>
        <id>http://whx828.github.io/s3/2</id>
        <content type="html" xml:base="http://whx828.github.io/s3/2">
            <![CDATA[<p>今天晚上有点累，同时闲得无聊，而且最近总被 GPT-4/ChatGPT/文心一言刷屏，突然也想跟把风玩玩 AI。</p>
<p>上网冲浪找到了这个项目：<a href="https://github.com/setzer22/llama-rs">LLaMA-rs</a>，是 <a href="https://github.com/ggerganov/llama.cpp">llama.cpp</a> 的 Rust 版本，正好 MacBook 也能跑，比较适合我。<br />
我尝试着 clone 了项目，想着看看能不能跑通，权当娱乐。</p>
<p>需要这么几步操作：</p>
<ol>
<li>
<p>首先你需要准备 LLaMA 模型，常规操作是到 facebook 那里慢悠悠地填邮件，等人家给你发链接，不过晚吃瓜有晚吃瓜的好处，网友是万能的，现在磁力链接都有了：<br />
<code>magnet:?xt=urn:btih:ZXXDAUWYLRUXXBHUYEMS6Q5CE5WA3LVA&amp;dn=LLaMA</code></p>
</li>
<li>
<p>简单瞅瞅，这些模型太大，我只是想玩一下，所以选择了最小的 7B</p>
</li>
<li>
<p>模型下载好之后需要按照 <a href="https://github.com/ggerganov/llama.cpp">llama.cpp</a> 项目的步骤继续：</p>
<ol>
<li>把模型挪到 <code>./models</code> 下</li>
<li>安装必要的依赖：<code>python3 -m pip install torch numpy sentencepiece</code></li>
<li>将 7B 模型转换为 ggml FP16 格式：<code>python3 convert-pth-to-ggml.py models/7B/ 1</code></li>
<li>将模型量化为 4 位：<code>./quantize.sh 7B</code></li>
</ol>
</li>
<li>
<p>通过上面一顿操作你就得到了 <code>./models/7B/ggml-model-q4_0.bin</code> 这个文件</p>
</li>
<li>
<p>友情提示下载的模型就有 10 几个 G，转化好的玩意也有 4G 多，所以你最好在等下载&amp;运行转换命令的时候找点事做，不然会非常无聊（说好的娱乐向呢。。。）</p>
</li>
<li>
<p>接下来 clone <a href="https://github.com/setzer22/llama-rs">LLaMA-rs</a> 项目，在 LLaMA-rs 项目的根目录下执行 <code>cargo build --release</code>，构建 Rust 项目（熟悉 Rust 的要注意目前 debug 模式会报错，必须是 release 模式才行）</p>
</li>
<li>
<p>构建完成之后就可以用 <code>cargo run --release -- &lt;ARGS&gt;</code> 命令运行了，人家给的例子是 <code>cargo run --release -- -m /data/Llama/LLaMA/7B/ggml-model-q4_0.bin -p &quot;Tell me how cool the Rust programming language is:</code> </p>
</li>
<li>
<p>一切顺利你会看到结果，大功告成！我跑出来的东西是这样的：</p>
</li>
</ol>
<p><img src="../../static/2023/llama-rs-result.png" alt="" loading="lazy"></p>
<blockquote>
<p>Tell me how cool the Rust programming language is: </p>
<ol>
<li>It’s compiled using standard techniques, but it has no runtime library (all classes are inlined into executables). So all kinds of things you wouldn’t normally have to worry about compile-time. </li>
<li>It can create a complete binary application from an XML file that specifies the class hierarchy and relationships - no other code is necessary or allowed! </li>
<li>The programming language looks like Java, but it has none of the overhead – it runs in memory at normal speed on modern hardware (i5+MacBookPro here). I’m really loving this because I can now write C-like</li>
</ol>
</blockquote>
<blockquote>
<p>告诉我，Rust 编程语言有多酷：<br />
1）它是使用标准技术编译的，但是它没有运行时库（所有类都插入了可执行文件中）。因此，您通常不必担心编译时的各种事情。<br />
2）它可以从 XML 文件中创建一个完整的二进制应用程序，该应用程序指定类层次结构和关系 - 不需要或允许其他代码！<br />
3）编程语言看起来像 Java，但没有开销 - 它以现代硬件的正常速度（i5+MacBookPro）在内存中运行。我真的很喜欢这个，因为我现在可以写类 C 语言</p>
</blockquote>
<p>AI 还是有点意思的，第一条还像那么回事，Rust 官方的确没有提供运行时，但是这意味着有更多的工作要在编译时去做啊，AI 的逻辑让人哭笑不得；<br />
第二条更加离谱，如果这里说 TOML 文件将是绝杀，可惜换不得；第三条又是说对了一部分，Rust 的确快，但和 Java 并没多少相似之处。</p>
<hr />
<p>再来看基于 Stanford Alpaca 的 <a href="https://github.com/antimatter15/alpaca.cpp">alpaca.cpp</a> 项目的神奇操作，步骤和前面的差不多，但是效果更好：</p>
<p><img src="../../static/2023/alpaca-cpp.png" alt="" loading="lazy"></p>
<blockquote>
<p>Rust has been described as “the most exciting new development in software engineering since C++”. It combines safety and performance, with a focus on correctness that makes it ideal for writing safe code. Rust also offers great tooling support from the community which allows you to write better programs faster than ever before!</p>
</blockquote>
<blockquote>
<p>Rust 被描述为“自 C++ 以来软件工程领域最激动人心的新发展”。它结合了安全性和性能，并注重正确性，这使其成为编写安全代码的理想选择。Rust 还提供来自社区的强大工具支持，使您能够比以往更快地编写更好的程序！</p>
</blockquote>
<p>这个效果就比前者好太多了，基本没有错误！</p>
<p>最恐怖的是，所有的这一切都是在我这台 2016 的老 MacBook 上完成的，没有什么显卡/GPU 加持，完全靠 CPU 也能做到这种程度，这样看来 ChatGPT 那种神乎其技的表现也就不足为奇了，所谓图灵测试根本是难不住它们的，依照这个速度发展下去，奇点一定会到来；<br />
这个世界太疯狂，未来会变成什么样子，真是令人期待！</p>
]]>
        </content>

        <author>
            <name>whx</name>
        </author>
    </entry>
    <entry>
        <title>2022 总结</title>
        <link rel="alternate" href="http://whx828.github.io/s3/1" type="text/html" title="2022 总结" />
        <published>2023-01-01</published>
        <updated>2023-01-01</updated>
        <id>http://whx828.github.io/s3/1</id>
        <content type="html" xml:base="http://whx828.github.io/s3/1">
            <![CDATA[<h1 id="2022 回顾 & 鞭尸" class="flex group">
<span>2022 回顾 & 鞭尸</span>
<a href="#2022 回顾 & 鞭尸"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h1>
<h2 id="个人能力" class="flex group">
<span>个人能力</span>
<a href="#个人能力"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
<h3 id="年初计划" class="flex group">
<span>年初计划</span>
<a href="#年初计划"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h3>
<ul>
<li>深度阅读 10 本左右的各领域书籍</li>
<li>争取输出自己的内容，读书笔记或者技术博客 5-6 篇</li>
<li>练习英语阅读能力，之后是听和说</li>
<li>锻炼身体，减肥 10 斤</li>
</ul>
<h3 id="执行情况" class="flex group">
<span>执行情况</span>
<a href="#执行情况"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h3>
<p><img src="../../static/2023/2022%20%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D.png" alt="" loading="lazy">2022 阅读书籍</p>
<ul>
<li>读了一共大概 6、7 本书吧，事实上没有太多时间读书</li>
<li>写了 1 篇博客，几乎剃了光头，现在看来 2022 年唯一的正式输出也稚嫩得可笑，毫无水平，留着警醒自己吧，不要什么垃圾都往外输出</li>
<li>保持阅读了英语内容，但没有学习英语，对英语失去了兴趣，我还有什么理由学习英语呢，尤其是在翻译软件异常发达的今天，明天有效果极好的同声传译软件出来我都不奇怪</li>
<li>身体一年不如一年，年末受到新冠的攻击，至今仍未痊愈</li>
</ul>
<h2 id="编程能力" class="flex group">
<span>编程能力</span>
<a href="#编程能力"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
<h3 id="个人展望" class="flex group">
<span>个人展望</span>
<a href="#个人展望"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h3>
<h4 id="年初计划" class="flex group">
<span>年初计划</span>
<a href="#年初计划"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h4>
<p>按照 <a href="https://zerotomastery.io/blog/learn-to-code-for-free/">Learn to code for free, get hired in 5 months, and have fun along the way</a> 的计划学习<br />
追加简单的计算机科学自学计划 2022.2.15</p>
<ol>
<li>成为一个具有职业水平的 Java 后端开发者（全年）</li>
</ol>
<blockquote>
<p>这一项估计不行了，计划赶不上变化</p>
</blockquote>
<ol start="2">
<li>练习一定的算法题目（全年）</li>
<li>成为一个优秀的 Rust 语言爱好者（后半年）</li>
</ol>
<h4 id="执行情况" class="flex group">
<span>执行情况</span>
<a href="#执行情况"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h4>
<p>第一个计划没有执行，我完全低估了前端开发的难度和逻辑，所累积的技术栈对于前端学习的帮助也非常小，学不下去也实属正常；<br />
第二个计划执行了一些，但不多，英语课程学习起来所花费的时间巨大，而收益却未知，我不知道是好还是坏，好在内容足够有趣。</p>
<p>前两项完全没做，没学 Java 也没学算法，甚至连数据结构都没学全；<br />
最后一项估计完成了 3、4 成左右的样子吧，Rust 的难度也不小，只是我还愿意往下学而已。</p>
<h3 id="学习路径" class="flex group">
<span>学习路径</span>
<a href="#学习路径"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h3>
<p>预计到 2023 年年初具备职业开发者的素质，争取走技术移民/独立开发者的路子。</p>
<h4 id="执行情况" class="flex group">
<span>执行情况</span>
<a href="#执行情况"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h4>
<p>很遗憾，还未达成职业水平，而且在上班前也不会达到吧，去年的我想得太美了，完全没意识到学一年编程就达到职业水平是凡人不可能完成的任务。</p>
<h2 id="阶段计划" class="flex group">
<span>阶段计划</span>
<a href="#阶段计划"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
<h3 id="阅读计划" class="flex group">
<span>阅读计划</span>
<a href="#阅读计划"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h3>
<h4 id="年初计划" class="flex group">
<span>年初计划</span>
<a href="#年初计划"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h4>
<ol>
<li>读完《计算机系统要素》</li>
<li>读完《CSAPP》</li>
<li>读完《操作系统导论》</li>
</ol>
<h4 id="执行情况" class="flex group">
<span>执行情况</span>
<a href="#执行情况"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h4>
<p>第一本读了一半，这本书其实也就值得读一半；<br />
走马观花地读完了第二本，实验和课后题完全没碰；<br />
最后一本读了三分之一。</p>
<h3 id="工作计划" class="flex group">
<span>工作计划</span>
<a href="#工作计划"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h3>
<h4 id="年初计划" class="flex group">
<span>年初计划</span>
<a href="#年初计划"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h4>
<ol>
<li><del>完成 WH 交代的任务</del>，顺利毕业</li>
<li><del>上手区块链、JavaScript 项目</del></li>
<li>每月输出内容取材于每周的周记，周记又源于日记</li>
<li>学习英语，认真读英语文章，保证质量</li>
</ol>
<h4 id="执行情况" class="flex group">
<span>执行情况</span>
<a href="#执行情况"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h4>
<p><img src="../../static/2023/2022%20%E5%91%A8%E6%8A%A5.png" alt="" loading="lazy">2022 周报</p>
<p>2022.4.16──2022.6.22 这段时间因学校封校，老师进不来，日子变得轻松的缘故下写了点 <a href="https://whx828.notion.site/3e61b415aabe410d8b3f37844dfb5e68?v=f23ac96cfb3a43558649ccb8382c2279">周报</a>，还有一篇 <a href="http://whx828.com/s2/1/">Rust 博客</a>；<br />
除此之外 2022 年什么都没输出，在年末也失去了耐心，没能完成很好的内容输出。</p>
<h3 id="简单的计算机科学自学计划" class="flex group">
<span>简单的计算机科学自学计划</span>
<a href="#简单的计算机科学自学计划"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h3>
<h4 id="年初计划" class="flex group">
<span>年初计划</span>
<a href="#年初计划"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h4>
<p>5-8 重点：</p>
<ol>
<li>Composing programs<br />
Coursera Programming Languages(ML, Racket, Ruby)</li>
<li>The Missing Semester of Your CS Education<br />
讲 Shell，Git，tmux 等等</li>
<li>Coursera Data Structures and Algorithms Specialization(UCSD)<br />
算法：贪心算法，分治算法，动态规划<br />
数据结构：动态数组，哈希表，二叉树</li>
<li>CSAPP, CMU: Intro to Computer Systems<br />
数据在计算机中存储，汇编，程序优化，内存分级，控制流</li>
<li>MIT 6.S081 OS<br />
系统调用，Page Table，Exception，多线程，进程等</li>
<li>MIT 6.824 分布式系统<br />
实现 RAFT 协议，使用 RAFT 协议搭建 KV Server，实现动态切片</li>
</ol>
<h4 id="执行情况" class="flex group">
<span>执行情况</span>
<a href="#执行情况"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h4>
<p>走马观花地看了 1，发现没什么意思，2 的东西挺好，把边角料讲好也是本事；还有大致过了一遍 5 的视频字幕，对 OS 有了点概念，除此之外没看什么课程。</p>
<h3 id="原则" class="flex group">
<span>原则</span>
<a href="#原则"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h3>
<p><strong>坚持一个目标不动摇</strong>，不要换来换去，别被别人影响，锻炼自己心态，什么时候天都塌不下来<br />
对于研究生期间遇到的项目，需要什么就学什么，不再进行项目相关扩展学习，专注于自己的学习计划<br />
三思而行，抛弃不该有的心理包袱，扩展网络上的人际交往</p>
<h4 id="执行情况" class="flex group">
<span>执行情况</span>
<a href="#执行情况"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h4>
<p>完全没有做到，一塌糊涂，心态随着「躺平」的深渊越来越近，不想关心一切；<br />
研究生期间的项目估计到此为止了，对我而言只剩下毕业论文；<br />
不仅没有扩展网络人际，甚至还断掉了两个现实中的关系，不过我只后悔为什么没有早点断，那样还能体面一点，和谐一点。</p>
<h3 id="研究生工作 2022.2-" class="flex group">
<span>研究生工作 2022.2-</span>
<a href="#研究生工作 2022.2-"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h3>
<p><del>建立一个无人工厂：</del></p>
<ol>
<li>建立 RFID、机器人、生产线组成的系统</li>
<li>基于 Rethink 机器人控制，把仿真控制程序下到实体机器人上，实现机器人操作</li>
<li>构建局域网，搭建 RFID 天线、其代码识别功能，机器人抓去工件（具有代码）</li>
<li>远程操控，通过手机操控该系统</li>
<li>建立与实体系统对应的元宇宙系统</li>
<li>元宇宙系统与实体系统实现链接、互动</li>
</ol>
<h4 id="执行情况" class="flex group">
<span>执行情况</span>
<a href="#执行情况"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h4>
<p>花了半年的时间才最终意识到我的研究生教育是个骗局，所有的一切除了毕业证书全都和我无关，我不应该花哪怕一秒钟在这些东西上面，因为完全都是浪费。当我知道这些的时候已经很晚了，可以说浪费了大半年的时间。</p>
<h3 id="自学课程更新 2022.3.11-" class="flex group">
<span>自学课程更新 2022.3.11-</span>
<a href="#自学课程更新 2022.3.11-"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h3>
<ul>
<li><a href="https://cs61a.org">CS 61A: Structure and Interpretation of Computer Programs</a></li>
<li><a href="https://sp18.datastructur.es/">CS 61B: Data Structures</a></li>
<li><a href="http://web.mit.edu/6.031/www/sp21/">6.031: Software Construction</a></li>
</ul>
<h4 id="执行情况" class="flex group">
<span>执行情况</span>
<a href="#执行情况"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h4>
<p>只看了 CS61B，还没看完。现在让我学的话我也只会学 CS61B，贪多嚼不烂。</p>
<h1 id="总结" class="flex group">
<span>总结</span>
<a href="#总结"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h1>
<h2 id="笔记情况" class="flex group">
<span>笔记情况</span>
<a href="#笔记情况"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
<p><img src="../../static/2023/2022%20%E6%80%BB%E7%BB%93.png" alt="" loading="lazy">2022 总结</p>
<p>看得出我还是记了不少笔记的，可惜没啥时间消化它们。2023 继续坚持。</p>
<h2 id="项目计划" class="flex group">
<span>项目计划</span>
<a href="#项目计划"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
<h3 id="markdown 格式化" class="flex group">
<span>Markdown 格式化</span>
<a href="#markdown 格式化"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h3>
<p>为啥想做这个东西，每次整理笔记的时候格式总是一团糟，网上找到的实现也不符合我的需求，干脆自己写一个吧。</p>
<h3 id="crane 语言" class="flex group">
<span>Crane 语言</span>
<a href="#crane 语言"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h3>
<p>读完 《Crafting Interpreter》总有种自己也写个语言的冲动，暂定名为 Crane，希望在 2023 年完成这个项目。</p>
<h2 id="碎碎念 & 发牢骚" class="flex group">
<span>碎碎念 & 发牢骚</span>
<a href="#碎碎念 & 发牢骚"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
<p>计划别搞太满，因为是没办法全部执行的。所以 2023 年我就不做什么计划了，把 2022 年没能搞定的任务接着往下完成。
接下来就随心所欲吧，因为不知道意外什么时候到来，人生要及时行乐。2022 年我失去了很多，但并未得到什么，我发现逼自己也没什么用，再怎么调低自己的期望也无法掩盖世道越来越艰难的事实。躺平不是自嘲，而是无奈的选择。<br />
写这篇总结之前我看了点别人的 2022 总结，怎么说呢，现在还在互联网上能表达自己生活的人，别管他们把自己的日子说得多么艰难，实际上还是对操蛋的生活有一定还手之力的家伙；而真正「弯路里没路的人」是「死得悄无声息」的，他倒下，然后死去，一点浪花都不会有，就像我的牢骚一样。<br />
这一年，好像大家心里累得连愤怒的力气都没有了，我是这样的，以前我心里还有点血气，现在我很少提得起兴致。「天道残缺匹夫补，只为苍生不为主。」匹夫何在？苍生何在？</p>
<blockquote>
<p>主又何在？</p>
</blockquote>
<p>我感到我离人很远。什么是爱具体的人？当我离开网络离人越近，当这个人越具体，我反而会越反感，越难以接受，我离「爱」这个动词越来越远，我好像并不知道「爱」是什么。<br />
我的耐心也在减少，我懒得再去装作礼貌，我讨厌他们，同时也不放过自己。</p>
<p>过去的一年岂是一篇小文就能总结？大概就这样吧。人生如果真的是缓慢受锤的过程的话，我希望 2023 锤得慢一点。</p>
]]>
        </content>

        <author>
            <name>whx</name>
        </author>
    </entry>
    <entry>
        <title>记一次 Rust 探险</title>
        <link rel="alternate" href="http://whx828.github.io/s2/1" type="text/html" title="记一次 Rust 探险" />
        <published>2022-04-17</published>
        <updated>2022-04-17</updated>
        <id>http://whx828.github.io/s2/1</id>
        <content type="html" xml:base="http://whx828.github.io/s2/1">
            <![CDATA[<h2 id="问题的起始" class="flex group">
<span>问题的起始</span>
<a href="#问题的起始"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
<p>最近在看《The Book》，第 17 章的 17.3 节里面有这样一个细节：</p>
<blockquote>
<p>……</p>
<p>请求审核博文来改变其状态</p>
<p>接下来需要增加请求审核博文的功能，这应当将其状态由 <code>Draft</code> 改为 <code>PendingReview</code>。示例 17-15 展示了这段代码：</p>
</blockquote>
<pre style="background-color:#fafafa;">
<span style="color:#fa6e32;">pub struct </span><span style="color:#399ee6;">Post </span><span style="color:#61676c;">{
</span><span style="color:#61676c;">    state</span><span style="color:#61676ccc;">: </span><span style="font-style:italic;color:#55b4d4;">Option</span><span style="color:#61676c;">&lt;</span><span style="font-style:italic;color:#55b4d4;">Box</span><span style="color:#61676c;">&lt;dyn State&gt;&gt;,
</span><span style="color:#61676c;">    content</span><span style="color:#61676ccc;">:</span><span style="color:#61676c;"> String,
</span><span style="color:#61676c;">}
</span><span style="color:#61676c;">
</span><span style="color:#fa6e32;">impl </span><span style="color:#399ee6;">Post </span><span style="color:#61676c;">{
</span><span style="color:#61676c;">   </span><span style="font-style:italic;color:#abb0b6;">// --snip--
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">pub fn </span><span style="color:#f29718;">new</span><span style="color:#61676c;">() </span><span style="color:#61676ccc;">-&gt;</span><span style="color:#61676c;"> Post {
</span><span style="color:#61676c;">        Post {
</span><span style="color:#61676c;">            state</span><span style="color:#61676ccc;">: </span><span style="font-style:italic;color:#55b4d4;">Some</span><span style="color:#61676c;">(</span><span style="font-style:italic;color:#55b4d4;">Box</span><span style="color:#ed9366;">::</span><span style="color:#61676c;">new(Draft {}))</span><span style="color:#61676ccc;">,
</span><span style="color:#61676c;">            content</span><span style="color:#61676ccc;">: </span><span style="font-style:italic;color:#55b4d4;">String</span><span style="color:#ed9366;">::</span><span style="color:#61676c;">new()</span><span style="color:#61676ccc;">,
</span><span style="color:#61676c;">        }
</span><span style="color:#61676c;">    }
</span><span style="color:#61676c;">
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">pub fn </span><span style="color:#f29718;">add_text</span><span style="color:#61676c;">(</span><span style="color:#ed9366;">&amp;</span><span style="color:#fa6e32;">mut </span><span style="color:#ff8f40;">self</span><span style="color:#61676c;">, </span><span style="color:#ff8f40;">text</span><span style="color:#61676ccc;">: </span><span style="color:#ed9366;">&amp;</span><span style="color:#fa6e32;">str</span><span style="color:#61676c;">) {
</span><span style="color:#61676c;">        </span><span style="font-style:italic;color:#55b4d4;">self</span><span style="color:#ed9366;">.</span><span style="color:#61676c;">content</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">push_str</span><span style="color:#61676c;">(text)</span><span style="color:#61676ccc;">;
</span><span style="color:#61676c;">    }
</span><span style="color:#61676c;">
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">pub fn </span><span style="color:#f29718;">content</span><span style="color:#61676c;">(</span><span style="color:#ed9366;">&amp;</span><span style="color:#ff8f40;">self</span><span style="color:#61676c;">) </span><span style="color:#61676ccc;">-&gt; </span><span style="color:#ed9366;">&amp;</span><span style="color:#fa6e32;">str </span><span style="color:#61676c;">{
</span><span style="color:#61676c;">        </span><span style="color:#86b300;">&quot;&quot;
</span><span style="color:#61676c;">    }
</span><span style="color:#61676c;">
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">pub fn </span><span style="color:#f29718;">request_review</span><span style="color:#61676c;">(</span><span style="color:#ed9366;">&amp;</span><span style="color:#fa6e32;">mut </span><span style="color:#ff8f40;">self</span><span style="color:#61676c;">) {
</span><span style="color:#61676c;">        </span><span style="color:#fa6e32;">if let </span><span style="font-style:italic;color:#55b4d4;">Some</span><span style="color:#61676c;">(s) </span><span style="color:#ed9366;">= </span><span style="font-style:italic;color:#55b4d4;">self</span><span style="color:#ed9366;">.</span><span style="color:#61676c;">state</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">take</span><span style="color:#61676c;">() {
</span><span style="color:#61676c;">            </span><span style="font-style:italic;color:#55b4d4;">self</span><span style="color:#ed9366;">.</span><span style="color:#61676c;">state </span><span style="color:#ed9366;">= </span><span style="font-style:italic;color:#55b4d4;">Some</span><span style="color:#61676c;">(s</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">request_review</span><span style="color:#61676c;">())
</span><span style="color:#61676c;">        }
</span><span style="color:#61676c;">    }
</span><span style="color:#61676c;">}
</span><span style="color:#61676c;">
</span><span style="color:#fa6e32;">trait </span><span style="color:#399ee6;">State </span><span style="color:#61676c;">{
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">fn </span><span style="color:#f29718;">request_review</span><span style="color:#61676c;">(</span><span style="color:#ff8f40;">self</span><span style="color:#61676c;">: </span><span style="font-style:italic;color:#55b4d4;">Box</span><span style="color:#61676c;">&lt;</span><span style="color:#fa6e32;">Self</span><span style="color:#61676c;">&gt;) </span><span style="color:#61676ccc;">-&gt; </span><span style="font-style:italic;color:#55b4d4;">Box</span><span style="color:#61676c;">&lt;dyn State&gt;</span><span style="color:#61676ccc;">;
</span><span style="color:#61676c;">}
</span><span style="color:#61676c;">
</span><span style="color:#fa6e32;">struct </span><span style="color:#399ee6;">Draft </span><span style="color:#61676c;">{}
</span><span style="color:#61676c;">
</span><span style="color:#fa6e32;">impl </span><span style="color:#61676c;">State </span><span style="color:#fa6e32;">for </span><span style="color:#399ee6;">Draft </span><span style="color:#61676c;">{
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">fn </span><span style="color:#f29718;">request_review</span><span style="color:#61676c;">(</span><span style="color:#ff8f40;">self</span><span style="color:#61676c;">: </span><span style="font-style:italic;color:#55b4d4;">Box</span><span style="color:#61676c;">&lt;</span><span style="color:#fa6e32;">Self</span><span style="color:#61676c;">&gt;) </span><span style="color:#61676ccc;">-&gt; </span><span style="font-style:italic;color:#55b4d4;">Box</span><span style="color:#61676c;">&lt;dyn State&gt; {
</span><span style="color:#61676c;">        </span><span style="font-style:italic;color:#55b4d4;">Box</span><span style="color:#ed9366;">::</span><span style="color:#61676c;">new(PendingReview {})
</span><span style="color:#61676c;">    }
</span><span style="color:#61676c;">}
</span><span style="color:#61676c;">
</span><span style="color:#fa6e32;">struct </span><span style="color:#399ee6;">PendingReview </span><span style="color:#61676c;">{}
</span><span style="color:#61676c;">
</span><span style="color:#fa6e32;">impl </span><span style="color:#61676c;">State </span><span style="color:#fa6e32;">for </span><span style="color:#399ee6;">PendingReview </span><span style="color:#61676c;">{
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">fn </span><span style="color:#f29718;">request_review</span><span style="color:#61676c;">(</span><span style="color:#ff8f40;">self</span><span style="color:#61676c;">: </span><span style="font-style:italic;color:#55b4d4;">Box</span><span style="color:#61676c;">&lt;</span><span style="color:#fa6e32;">Self</span><span style="color:#61676c;">&gt;) </span><span style="color:#61676ccc;">-&gt; </span><span style="font-style:italic;color:#55b4d4;">Box</span><span style="color:#61676c;">&lt;dyn State&gt; {
</span><span style="color:#61676c;">        </span><span style="font-style:italic;color:#55b4d4;">self
</span><span style="color:#61676c;">    }
</span><span style="color:#61676c;">}
</span><span style="color:#61676c;">
</span></pre>
<blockquote>
<p>……</p>
<p><strong>我们需要将 <code>state</code> 临时设置为 <code>None</code> 来获取 <code>state</code> 值，即老状态的所有权，而不是使用 <code>self.state = self.state.request_review();</code> 这样的代码直接更新状态值。这确保了当 <code>Post</code> 被转换为新状态后不能再使用老 <code>state</code> 值。</strong></p>
<p>……</p>
</blockquote>
<p>这里让我非常困惑，我认为并不是这个原因，因此找了不少解释，以下是总结。</p>
<h2 id="box 的性质" class="flex group">
<span>Box 的性质</span>
<a href="#box 的性质"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
<p>首先来看可变性。<br />
在 Rust 中，一个变量是否可变，取决于是否用 <code>mut</code> 修饰变量绑定。</p>
<p>如果我们用 <code>let var : T</code> 声明，那么 <code>var</code> 是不可变的；而且 <code>var</code> 内部所有的成员也都是不可变的；<br />
如果我们用 <code>let mut var : T</code> 声明，那么 <code>var</code> 是可变的，相应的它的内部所有成员也都是可变的。<br />
这样的话，如果有个结构体引用 <code>&amp;SomeStruct</code>，则 <code>SomeStruct</code> 的所有字段都是不可变的。<br />
但在实际开发中，确实存在需要结构体中的某个字段可变的情况。针对这种情况，Rust 的标准库中有个 <code>std::cell</code> 模块，通过共享的可变容器允许以受控的方式进行可变性操作。</p>
<p>在 <code>std::cell</code> 模块中的 <code>Cell</code> 和 <code>RefCell</code> 是实现内部可变性的<strong>容器</strong>，在保持容器不被 <code>drop</code> 的情况下可以修改其中的值；而 <code>Box</code> 虽然一直都被拿来和前两个一起讨论，但 <code>Box</code> 并没在 <code>std::cell</code> 模块中，它对可变性其实没啥限定。<br />
<code>Box</code> 是一个<strong>指针</strong>，有所有权和生命周期，指向堆上的某个位置，和普通的指针不同的是，它<strong>独占</strong>了对数据的所有权；<br />
<code>Cell</code> <strong>不是</strong>一个指针，<code>Cell&lt;T&gt;</code> 只是把数据 T 包装一下，告诉你它有“内部可变性”，数据还是那些数据。</p>
<p>其次来看所有权规则。<br />
<code>Box&lt;T&gt;</code> 不是 <code>Copy</code> 类型，因为 <code>Box</code> 拥有分配在堆上的缓冲区，非 <code>Copy</code> 类型如果采用逐位复制，那么会使编译器无法分辨哪个值需要对<strong>被引用的原始资源</strong>负责。</p>
<p>性质已经搞清，接下来我们来看具体问题。</p>
<h2 id="为什么直接赋值不行" class="flex group">
<span>为什么直接赋值不行</span>
<a href="#为什么直接赋值不行"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
<p>我在 stackoverflow 上找到一个有关的问答，回答者把它换成了直接版本：</p>
<pre style="background-color:#fafafa;">
<span style="color:#fa6e32;">pub struct </span><span style="color:#399ee6;">Post </span><span style="color:#61676c;">{
</span><span style="color:#61676c;">    state</span><span style="color:#61676ccc;">: </span><span style="font-style:italic;color:#55b4d4;">Box</span><span style="color:#61676c;">&lt;dyn State&gt;,
</span><span style="color:#61676c;">    content</span><span style="color:#61676ccc;">:</span><span style="color:#61676c;"> String,
</span><span style="color:#61676c;">}
</span><span style="color:#61676c;">
</span><span style="color:#fa6e32;">trait </span><span style="color:#399ee6;">State </span><span style="color:#61676c;">{
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">fn </span><span style="color:#f29718;">request_review</span><span style="color:#61676c;">(</span><span style="color:#ff8f40;">self</span><span style="color:#61676c;">: </span><span style="font-style:italic;color:#55b4d4;">Box</span><span style="color:#61676c;">&lt;</span><span style="color:#fa6e32;">Self</span><span style="color:#61676c;">&gt;) </span><span style="color:#61676ccc;">-&gt; </span><span style="font-style:italic;color:#55b4d4;">Box</span><span style="color:#61676c;">&lt;dyn State&gt;</span><span style="color:#61676ccc;">; 
</span><span style="color:#61676c;">}
</span><span style="color:#61676c;">
</span><span style="color:#fa6e32;">impl </span><span style="color:#399ee6;">Post </span><span style="color:#61676c;">{
</span><span style="color:#61676c;">    </span><span style="font-style:italic;color:#abb0b6;">// ... 
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">pub fn </span><span style="color:#f29718;">request_review</span><span style="color:#61676c;">(</span><span style="color:#ed9366;">&amp;</span><span style="color:#fa6e32;">mut </span><span style="color:#ff8f40;">self</span><span style="color:#61676c;">) {
</span><span style="color:#61676c;">        </span><span style="font-style:italic;color:#55b4d4;">self</span><span style="color:#ed9366;">.</span><span style="color:#61676c;">state </span><span style="color:#ed9366;">= </span><span style="font-style:italic;color:#55b4d4;">self</span><span style="color:#ed9366;">.</span><span style="color:#61676c;">state</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">request_review</span><span style="color:#61676c;">()</span><span style="color:#61676ccc;">;
</span><span style="color:#61676c;">    }
</span><span style="color:#61676c;">    </span><span style="font-style:italic;color:#abb0b6;">// ... 
</span><span style="color:#61676c;">}
</span></pre>
<p>编译器报错：</p>
<pre style="background-color:#fafafa;">
<span style="color:#61676c;">self.state = self.state.request_review();
</span><span style="color:#61676c;">             ^^^^^^ move occurs because `self.state` has type `std::boxed::Box&lt;dyn State&gt;`, which does not implement the `Copy` trait&#39;.
</span></pre>
<p>原回答：<br />
This is because calling <code>State::request_review</code> will move <code>Box&lt;self&gt;</code>, which is allocated on heap, and Rust doesn’t allow you to just move values away from heap unless you implement <code>Copy</code>, otherwise what’s left there? The book uses <code>Option::take()</code> to move ownership out and leave <code>None</code> on the place.</p>
<p>翻译如下：<br />
这是因为调用 <code>State::request_review</code> 将 <code>move</code> 分配在堆上的 <code>Box&lt;self&gt;</code>，而 Rust 不允许你将值从堆中 <code>move</code>，除非你实现 <code>Copy</code>，否则原值还剩下什么呢？The book 里面使用 <code>Option::take()</code> 将所有权移出，并为原值保留了 <code>None</code> 。</p>
<p>其实已经讲得很清楚了，但我还要问一句：<code>move</code> 发生在哪里？</p>
<pre style="background-color:#fafafa;">
<span style="font-style:italic;color:#55b4d4;">self</span><span style="color:#ed9366;">.</span><span style="color:#61676c;">state </span><span style="color:#ed9366;">= </span><span style="font-style:italic;color:#55b4d4;">self</span><span style="color:#ed9366;">.</span><span style="color:#61676c;">state</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">request_review</span><span style="color:#61676c;">()</span><span style="color:#61676ccc;">;
</span></pre>
<p>这一句中的 <code>self.state.request_review();</code> 使得结构体 <code>Post</code> 的 <code>state</code> 字段被 <code>request_review()</code> 方法赋了新值，并取得了 <code>state</code> 的所有权，此时 <code>self.state</code> 的所有权转移进了 <code>request_review()</code> 方法内，<code>self.state</code> 变成未初始化状态，而 Rust 编译器禁止使用未经初始化的变量，因为这会产生未定义行为。<br />
因此编译器报错，还指出了我们没有为 <code>std::boxed::Box&lt;dyn State&gt;</code> 实现 <code>Copy</code> trait，如果实现了这个 trait，<code>self.state</code> 在 <code>self.state.request_review()</code> 之后依然能保持初始化状态，也就可以完成 <code>self.state =</code> 这部分的赋值了。</p>
<h2 id="2023.2.16 追加" class="flex group">
<span>2023.2.16 追加</span>
<a href="#2023.2.16 追加"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
<p>再读《The Book》，想到自己还写过这么一篇文章，回来看的时候发现有个地方没说透：</p>
<blockquote>
<p>Rust 不允许你将值从堆中 <code>move</code>，除非你实现 <code>Copy</code></p>
</blockquote>
<p>这句话什么意思？还是要看<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=dcc068cc77c38b8a929b9177a11500ec">报错信息</a>：</p>
<pre style="background-color:#fafafa;">
<span style="color:#61676c;">   Compiling playground v0.0.1 (/playground)
</span><span style="color:#61676c;">error[E0507]: cannot move out of `self.state` which is behind a mutable reference
</span><span style="color:#61676c;">  --&gt; src/lib.rs:12:22
</span><span style="color:#61676c;">   |
</span><span style="color:#61676c;">12 |         self.state = self.state.request_review();
</span><span style="color:#61676c;">   |                      ^^^^^^^^^^ ---------------- `self.state` moved due to this method call
</span><span style="color:#61676c;">   |                      |
</span><span style="color:#61676c;">   |                      move occurs because `self.state` has type `Box&lt;dyn State&gt;`, which does not implement the `Copy` trait
</span><span style="color:#61676c;">   |
</span><span style="color:#61676c;">note: this function takes ownership of the receiver `self`, which moves `self.state`
</span><span style="color:#61676c;">  --&gt; src/lib.rs:7:23
</span><span style="color:#61676c;">   |
</span><span style="color:#61676c;">7  |     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;; 
</span><span style="color:#61676c;">   |                       ^^^^
</span><span style="color:#61676c;">
</span><span style="color:#61676c;">For more information about this error, try `rustc --explain E0507`.
</span><span style="color:#61676c;">error: could not compile `playground` due to previous error
</span></pre>
<p>我们的操作会 <code>cannot move out of *self.state* which is behind a mutable reference</code>，也就是说会在可变引用时 <code>move</code> 变量（转移所有权）。<br />
看一下函数签名： <code>fn request_review(&amp;mut self)</code>，果然使用的是 <code>Post</code> 的可变引用（也就是 <code>&amp;mut self</code>），然后在 <code>self.state.request_review()</code> 这一步时 <code>move</code> 了 <code>self.state</code>，如果 <code>self.state</code> 没有实现 <code>Copy</code> 这个 trait，那么根据 Rust 规则，使用可变引用时是不能 <code>move</code> 的，一旦 <code>move</code> 了，对象的内存地址改变了，那引用还有效吗？</p>
<ul>
<li>从借用规则角度看，可变引用是「独占引用」，也即在存在可变引用的时候是不能其他引用的，如果把值看成一种「可变引用」，那么很明显发生了冲突，之前的可变引用很可能就失效了。</li>
<li>从所有权角度看，可以把可变引用看成持有一段时间的所有权的值的特殊状态，这段时间内原值是不拥有所有权的，所以原值也没有能力去 <code>move</code>。</li>
<li>实现了 <code>Copy</code> trait 意味着不会真的转移所有权，而是会原封不动地复制一份出去，不会对原值有影响，因此引用就还会是有效状态。</li>
</ul>
<p>说了这么多，让我看看书里的操作是什么：</p>
<pre style="background-color:#fafafa;">
<span style="color:#fa6e32;">impl </span><span style="color:#399ee6;">Post </span><span style="color:#61676c;">{
</span><span style="color:#61676c;">    </span><span style="font-style:italic;color:#abb0b6;">// --snip--
</span><span style="color:#61676c;">    </span><span style="color:#fa6e32;">pub fn </span><span style="color:#f29718;">request_review</span><span style="color:#61676c;">(</span><span style="color:#ed9366;">&amp;</span><span style="color:#fa6e32;">mut </span><span style="color:#ff8f40;">self</span><span style="color:#61676c;">) {
</span><span style="color:#61676c;">        </span><span style="color:#fa6e32;">if let </span><span style="font-style:italic;color:#55b4d4;">Some</span><span style="color:#61676c;">(s) </span><span style="color:#ed9366;">= </span><span style="font-style:italic;color:#55b4d4;">self</span><span style="color:#ed9366;">.</span><span style="color:#61676c;">state</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">take</span><span style="color:#61676c;">() {
</span><span style="color:#61676c;">            </span><span style="font-style:italic;color:#55b4d4;">self</span><span style="color:#ed9366;">.</span><span style="color:#61676c;">state </span><span style="color:#ed9366;">= </span><span style="font-style:italic;color:#55b4d4;">Some</span><span style="color:#61676c;">(s</span><span style="color:#ed9366;">.</span><span style="color:#f07171;">request_review</span><span style="color:#61676c;">())
</span><span style="color:#61676c;">        }
</span><span style="color:#61676c;">    }
</span><span style="color:#61676c;">}
</span></pre>
<p>人家的 <code>state</code> 用 <code>Option</code> 给包住了，而且取值和赋值是分开写的，没有写在一行里，从 <code>take</code> 的签名：<code>pub fn take(&amp;mut self) -&gt; Option&lt;T&gt;</code> 中看出 <code>take</code> 用的是可变借用而不是 <code>self</code>，也就没有 <code>move</code> 了，同时生命周期推断也能发挥作用，当然就规避掉了这些问题。</p>
<p>问题解决！感谢这些在网上无私分享知识的人们！</p>
<h2 id="参考阅读" class="flex group">
<span>参考阅读</span>
<a href="#参考阅读"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
<ol>
<li><a href="https://stackoverflow.com/questions/57193489/why-do-we-need-to-call-take-for-optiont-variable">why do we need to call take() for Option&lt;T&gt; variable</a></li>
<li><a href="https://rustwiki.org/zh-CN/rust-by-example/scope/move.html">所有权和移动</a></li>
<li><a href="https://rustwiki.org/zh-CN/rust-by-example/variable_bindings/declare.html">变量先声明</a></li>
<li><a href="https://www.archgrid.xyz/2022/03/rust-ownership/">聊聊 Rust 中的所有权机制</a></li>
<li><a href="https://ipotato.me/article/57">Rust 中几个智能指针的异同与使用场景</a></li>
<li><a href="https://rustcc.cn/article?id=37d1cb4f-5cc9-4adc-b41a-dbe4914bf4b5">【Rust 每周一知】如何理解 Rust 中的可变与不可变？</a></li>
</ol>
]]>
        </content>

        <author>
            <name>whx</name>
        </author>
    </entry>
    <entry>
        <title>杭州游记</title>
        <link rel="alternate" href="http://whx828.github.io/s1/2" type="text/html" title="杭州游记" />
        <published>2021-07-03</published>
        <updated>2021-07-03</updated>
        <id>http://whx828.github.io/s1/2</id>
        <content type="html" xml:base="http://whx828.github.io/s1/2">
            <![CDATA[<p>我毕业了，为了出来散心，选择到杭州旅游。</p>
<p>为什么来杭州呢？也没有什么特别的理由，首先我想来一座南方的城市，感受一下和北方的不同；其次去哪里无所谓，重要的是独自旅行的过程，虽然也是一种无奈；另外杭州的名气比较响亮：“上有天堂，下有苏杭”，浙江也是社会主义共同富裕的先行示范区，我想看看是怎么个先行示范的样子。</p>
<p>一直到旅程结束我在家里写这一篇博客的时候，都很难讲杭州是一座怎样的城市，限于各种原因我只能走马观花：杭州看起来年轻十足，年轻小伙子姑娘很多；杭州又十分忙碌，晚上10点的地铁依然是人挤人；杭州也有闲散舒适，这里的老头一样喜欢饭后打牌；杭州同时繁华，这里城市建设一流，消费主义盛行，花花世界迷人眼，各种商场随处可见，仿佛就是要人们“消费、消费、消费”，可能是浙江人有钱不在乎这些，也可能是我在景区待久了的原因。但景区也有景区的好处，比如杭州的垃圾箱和公共厕所很多，这一点确实很方便旅客。总之，经过几天的旅行我还是难以看懂这里，但已经知道这里和我从前待过的任何一处都很不一样。</p>
<p>杭州大妈也很热情，得知我是从辽宁来的时候纷纷表示：“哦呦，好远”，“你北方人不习惯吧”，“杭州菜偏甜”等等，另一种热情是景区的大妈，她们热心的方式是请你“喝茶”，来之前我查了一下杨梅岭骗局，对此早有戒心。</p>
<p>这次旅行中也遇到了很多有意思的人：青旅的舍友王祚彦先生，一位执意寻找”西湖老公“的江苏台湾冒险家，他的旅行经历相当丰富，也给我很多见闻和思考；永福寺的哈尔滨老奶奶，年轻时在北京教书，退休之后在各地旅游，是一位非常坚定的”考研党“；还有很多热情的杭州人，他们是这个闷热城市里的习习凉风，吹散我很多疲惫，在此诚心谢谢他们，使我的旅行不仅仅是旅行。</p>
<p>用双脚丈量土地这个说法听起来很浪漫，实际上的感受更多是一个字：累。在路上和日常的生活感受完全不一样，我也开始理解为什么有很多人迷恋这种在路上的感觉，不仅仅是娱乐和享受，而是追求一种未知的改变，这种感觉可以赋予人一种生活的激情，焕发出新的活力。</p>
<p>短短四五天，毕业旅行走到尾声，我挥一挥衣袖，带走了很多照片，也算不虚此行，说罢杭州好，我还是思念辽东的凉爽。</p>
<p><strong>注</strong>：本文最开始写在 Notion 上，由于照片太多，没有把照片上传到 GitHub，所以想看照片的，请移步我的 <a href="https://whx828.notion.site/7990fe0b7f2944908d84f6d1f2f05ba1">Notion</a> 站点。</p>
]]>
        </content>

        <author>
            <name>whx</name>
        </author>
    </entry>
    <entry>
        <title>把自己作为方法</title>
        <link rel="alternate" href="http://whx828.github.io/s1/1" type="text/html" title="把自己作为方法" />
        <published>2021-06-05</published>
        <updated>2021-06-05</updated>
        <id>http://whx828.github.io/s1/1</id>
        <content type="html" xml:base="http://whx828.github.io/s1/1">
            <![CDATA[<p>其实是读书笔记。</p>
<strong><h2 id="北大青年的焦虑" class="flex group">
<span>北大青年的焦虑</span>
<a href="#北大青年的焦虑"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>我妈妈回了一封信，我的印象比较深，她说她年轻的时候什么都学苏联，现在什么都学西方，这是一个问题。</p>
</blockquote>
<p>所以中国的情况变化了吗？这是一个问题。我们究竟是谁？要干什么？</p>
<blockquote>
<p>我感觉他们对这个社会在今天发生什么也没有兴趣。</p>
</blockquote>
<p>可能确实如此，互联网的信息密集令人迷失，即使什么都不做也会有“算法”给你找乐子，虽然那不一定算是乐子。</p>
<blockquote>
<p>他们对这些事情不感兴趣。不感兴趣，又写这方面的文章，就很空洞，里面没有什么实在的观察。</p>
</blockquote>
<p>有些“学人”只是为了表面的享受，学术并没有走进他们的生活。</p>
<blockquote>
<p>大二以后，我比较重视数学和英语，觉得这是比较实在的东西，也去学经济学的课，剩下的时间就是做“浙江村”调查，以及搞社团</p>
</blockquote>
<p>项飙在他大二的时候觉得数学和英语是比较实在的，联系到他求学的年代是90年代初期，这么一算，30年过去了，我倒没在大二产生这样的想法，而是大一就认识到了。</p>
<p>但这也没能如何，毕竟人家上的是北大。不过跨越这么多年，大学生所产生的想法依然有一定程度的重叠，这是很奇妙的。</p>
<p>项飙还提到做调查和搞社团，放到今天来看这就是做比赛和玩社团的翻版，项飙做的调查使他的起步很高，但也许并不是出于功利想法，今天可就不一样了。</p>
<p>今天的比赛之类没有那么学术，甚至也不是为了娱乐，而是规则扭曲下的产物，核心在于利益竞争；至于社团，年轻人甚至不屑于跟现实世界里身边的人沟通，当然他们到了互联网上，到了游戏里又是一副样子了，可想而知社团的情况，一潭死水而已。</p>
<blockquote>
<p>青年很重要，不在于我们去回想自己的青年时光，而是用今天青年的眼光去拷问我们，让他们来“审判”我们，这样才能有更真的东西，我们才有机会来反思自己。</p>
</blockquote>
<p>每一代青年都是特定时代的产物，其中也会有怪胎。</p>
<p>不过每代人都觉得自己的时代是最乏味的，其实没有什么可拷问。年轻人不关心这些。</p>
<blockquote>
<p>这种学生下海赚钱的事其实在1991年就有了，但在1992年一下子爆发出来，市场经济被认为是正统。各种文化现象也重新出来，比如新一轮“国学热”。</p>
</blockquote>
<p>这一段令我印象深刻的是项飙居然可以如此清晰地记住像“1991年”这样的时间节点，今天的中国我很难对某件事有清晰而具体的隔断，一般是以段时间来划分。</p>
<p>另一方面赚钱的事其实早就有了，罗马不是一天建成的，社会风气也不是一天就变坏的。</p>
<blockquote>
<p>资源是什么意思呢？就是在私有化市场经济之后，原来我们生存所需要的物质，现在转化成了潜在的资源，是可以升值的。你一定要占据，要有明确的产权。</p>
</blockquote>
<p>这一段相当精辟。 非常准确传神地带有一种社会风向转变的角度的叙事，有一种醒悟感：原来不能卖的现在可以卖了，世界的规则变了。大多数人们并不知道的是，某种残酷就要到来。</p>
<blockquote>
<p>同时我们对腐败官员的揭露，却把大量篇幅放在男女关系上，而对这个人究竟怎么贪污、制度设计哪里有问题、贪污造成的具体后果又讲的很虚幻？</p>
</blockquote>
<p>很本质也很准确，不过这是讲不了的问题，项飙这样说很明显透出一种学者的稚气，其实虚幻已经给你答案了不是吗。</p>
<strong><h2 id="研究“浙江村”" class="flex group">
<span>研究“浙江村”</span>
<a href="#研究“浙江村”"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<p>很有意思的一点是之前认为“浙江村”在温州，原来是在北京。这样项飙上大学的时候去做研究就说的通了，毕竟那个年代不太可能长期两地来回跑。</p>
<p>由此看来，一个人的故乡很重要，例如项飙早期最重要的调查其实都没逃出他的“温州”，不过这也很合理，谁也不是石头缝里蹦出来的。</p>
<blockquote>
<p>冲动是每个人都有的，关键不在于你有没有冲动，而在于你是不是让冲动推着你走。</p>
</blockquote>
<p>我几乎从未让冲动推着走过，也许这就是我目前还是一事无成的原因。</p>
<p>项飙的“浙江村”调查，在他的叙述来看，完全是一副高材生的典型成功案例，站在高台上做一些不那么容易的事，只要做出水准之上的东西就足以收获很多。</p>
<blockquote>
<p>因为我们大量的信息和思考方式是一定要通过文字表达出来的，积累确实很重要。</p>
</blockquote>
<p>文字 → 表达，这是很多人都提到过的概念，我也认为文字传递信息，高效而方便。虽然不像游戏、视频那样给人很高的刺激，但是性价比很好。</p>
<blockquote>
<p>这是我长期以来的一个弱点，还在挣扎当中。我必须要追赶，但也不能够放弃自己的特点，把自己搞成那样的人。怎么弄现在没有结论，还在继续追赶，我们二十年以后可以再讨论这个问题。</p>
</blockquote>
<p>人人皆有弱点，即使像项飙这样的大学者也不例外。</p>
<p>我认为得到一些就会失去一些，如果我的偏好对我而言我足够喜欢，那么我会接受拥有他而失去的代价。</p>
<p>直接有直接的好，含蓄有含蓄的美。</p>
<blockquote>
<p>理论不在于新不新、深不深、更不在于正确不正确，而是能不能形成沟通性。</p>
</blockquote>
<p>这恰恰是最难的一点，和谁去沟通？</p>
<blockquote>
<p>艺术上的热情还是比较自然的，爱画画的人总是爱画画，但其他工作，比如研究性的、公益性的，会牵扯到很多很繁琐的细节，确实要有一种持续的热情。不能完全靠自发，而是需要通过教育。艺术真正的魅力是产生一种视觉效果，让对方去思考、反思，有思考的引带力。</p>
</blockquote>
<p>为了生活而又高于生活。</p>
<blockquote>
<p>如果赚钱糊口不是主要的目的了，你的生活意义是什么，你怎么和社会形成关系？</p>
</blockquote>
<p>到这一步我至少5-10年，所以不用急着回答。</p>
<strong><h2 id="边缘与中心" class="flex group">
<span>边缘与中心</span>
<a href="#边缘与中心"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>真正的英雄不是改变世界，而是改变自己生活的每一天。</p>
</blockquote>
<p>醍醐灌顶。</p>
<blockquote>
<p>边缘的人要进入中心的欲望特别强，这当然会让人发挥很大的能动性，但造成各种扭曲。而且一旦进入中心之后，很多人变质腐败，因为他们从来没有把自己是谁想清楚，存在就是为了进入中心，把生他养他的土地、和周边人的关系都放弃了，变成没有原则的人。人生活中的原则不是靠抽象理念来维持的，都是靠具体的社会关系，这个当然是儒家的思想，但它确实有它的道理。如果跟周边的人、生活的世界关系不清楚，就会变成机会主义者，其他人都成了利用工具。</p>
</blockquote>
<p>基本把人的割裂讲明白了，所以把自己想明白就是在救别人。</p>
<blockquote>
<p>中国历史上的强大中心，很大度上是靠把这个中心内化，每个地方都觉得自己是个小中心，所以都会比较从容。然后把它在象征意义上给拢起来，所以既有大一统，但是又不会削尖脑袋往上爬，觉得自己的生活一无是处。其实中心对很多边缘地方是不管的，地方有很强的自主性，是那种柔性的、开放的关系。今天“地方”的文化意义真的是被抽空了， 搞一些地方博物馆、旅游，都不能够进入人心，所以处理好“边缘”和“中心”的关系是很重要的。</p>
</blockquote>
<p>角度很奇妙，同时很合理地解答了我心中长久以来的困惑，讲明白了地方和中央的关系：你当大哥，我做小弟，但咱也是个土皇帝，犹如各玩各的、貌合神离的所谓“夫妻”那般暧昧。</p>
<blockquote>
<p>大一统并不意味着一个刚性结构，但现在环境已经变了，今天我们是一个很强大的国家，确实需要强大的中心，因为有资源再分配的问题，比如上海和西藏的关系，要有互相帮助的精神。所以我强调文化和社会的自主性，但是在经济上，市场要统一，资源上，通过行政力量来二次分配，还有军队税收，这些都不能放松。第二个变化就是全球化。自洽不能是封闭起来的自洽，而是每个地方都是一个小的中心，是汇集的地方，一个穴位，贯通全身，要用这样的方式去思考。</p>
</blockquote>
<p>这个回答很有中国味道。</p>
<blockquote>
<p>那时中国对世界的影响，我觉得比今天要大。今天我们究竟摸索出了一条清晰的道路，或者是提供了一个很大的理想吗？今天的情况又不一样，今天的中国走向世界，主要不是靠输出理念，而是靠做贸易。</p>
</blockquote>
<p>输出革命和做生意可不一样。</p>
<blockquote>
<p>但更可能的是，要等一批人积累起来以后，才会对这个世界有普遍性的启发。中国是在这样一个全球化的环境下崛起，靠中国的独特性去讲世界的普遍性问题，这个蛮牵强，还不如把自己具体的问题讲清楚。把这一角讲清楚，其实就是全世界的话语。</p>
</blockquote>
<strong><h2 id="个人危机" class="flex group">
<span>个人危机</span>
<a href="#个人危机"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>如果我不在当地泡，就是在说空话，唯一的干货来自人民群众。 观点属于人民，把观点整理出来，这个就是我们的工作。</p>
</blockquote>
<p>这两句话的左派气质已经藏不住了。</p>
<blockquote>
<p>不要怕边缘，或者知识不够，把自己的不够、天真真实地体现出来，就会很可爱，不要装腔作势。只有知道了你的真实性之后，才可以信任你。当然东方文化在政治上是相反的，这些东西都要被屏蔽，领导人不是个人，他是权力的化身，这就是不太一样的理解。到了牛津，我很感谢他们给我这么一个工作，使得我能想这些问题。</p>
</blockquote>
<p>真实是强大的力量，当然恐惧也是。</p>
<blockquote>
<p>“距离感”是分析上、方法上的概念，它和切入性是一种辩证关系。距离感不是指对问题的关心程度、对事实的熟悉程度，这些不能有距离感，越近越好，要把自己融进去。但在分析的时候，要有登上山丘看到平原的心态，才会比较客观、灵活、全面。</p>
</blockquote>
<p>分寸感能令双方感觉从容不迫。</p>
<strong><h2 id="什么是批判" class="flex group">
<span>什么是批判</span>
<a href="#什么是批判"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>学术也是这样，不能靠直觉去判断，一定要去证明它，要去展示结论是怎么达到的。往往越是明显的结论，越难去证明，但是一旦证明了以后，会是很大的贡献。</p>
</blockquote>
<p>返璞归真，最难是真。</p>
<strong><h2 id="理解的学问" class="flex group">
<span>理解的学问</span>
<a href="#理解的学问"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>有人甚至断言理解是不可能的。您怎么看？</p>
</blockquote>
<ul>
<li>理解是很自然的，不难，重要的是怎样不去拒绝理解。</li>
<li>要真的懂你，聊一聊是不够的，因为我不知道你从哪里来的这些感觉， 所以一定要知道你的世界。从了解开始，才能真正地理解。</li>
</ul>
<p>重要的是怎样不去拒绝理解这句话说出了关键，也许自己应该放下那不该有的傲慢，真诚地对待人类。</p>
<blockquote>
<p>要把他的言和行都看作是他的行动。只有通过这样理解，我们才知道我们应该怎么面对这些社会病态：不能把人一棍子打死，要考虑如何沟通，否则对罪犯就只有放纵和消灭两种态度了，没有教育改造一说了。</p>
</blockquote>
<p>世界当然不是非黑即白的，可是</p>
<strong><h2 id="访谈之前" class="flex group">
<span>访谈之前</span>
<a href="#访谈之前"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>社会科学告诉你，其实没有什么很强的规律，都在于自己怎么样去理解这个世界，怎么样主动地采取行动。可能会有大的图景，但没有所谓的规律，因为一旦发现规律，那么一切到此为止，就不需要再去做工作了。</p>
</blockquote>
<p>这是一种反直觉式的思考，甚至可以说不太理性，很唯心，和工科思维很不一样。</p>
<blockquote>
<p>社会科学首先是关于你的，然后才是关于社会的。</p>
</blockquote>
<p>其实任何一门科学都差不多吧，先从自身角度出发，然后扩展到很宏大的层面。</p>
<blockquote>
<p>在中国，很多事情能不能撑下来，关键在于有没有这口气，如果你有这种小型的团结，有时候像牛皮糖一样，这个事情也就拖过去了，能做下去。不要期望有一个人帮你挡，有困难大家一起面对。</p>
</blockquote>
<p>这个就和PHT想要抱团的想法不谋而合，这么看来即便在异国，他的思维也没有脱离中国太多。</p>
<p>而我有更加现在中国的看法，像张一鸣最近把字节交给和自己一起创业的南开的梁汝波，这就是普罗大众能接触到的这种小型团结的体现之一。</p>
<p>因此给我的启示之一是：对每个人来说，小团体是必然要出现的，你可以游离在大团体中，但必然要有自己的小团体，要有一处互相支撑的地方。</p>
<strong><h2 id="牛津记忆" class="flex group">
<span>牛津记忆</span>
<a href="#牛津记忆"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>这种一对一的辅导最大的好处是什么？他们说最大的好处就是躲不过，懂就是懂，不懂就是不懂</p>
</blockquote>
<p>条件所限，我只能自己给自己一对一辅导了。</p>
<blockquote>
<p>社会生活里有很多问题都是老问题</p>
</blockquote>
<p>因此很大一部分的经验还没有失效，关键在于你要分清楚哪些问题是老问题。</p>
<blockquote>
<p>表面上是政府在办牛津，事实上是牛津在办政府。</p>
</blockquote>
<p>这话说的，牛气！不过清北也差不多了？当然，不要忽视东方霍格沃兹。</p>
<blockquote>
<p>其实大学的作用就是提供了一个安全的环境，让你做思想上的各种探索。</p>
</blockquote>
<p>说的有一半贴切，一半理想化。比如我到想起来要关注思想的时候人多半已经不在大学里了。</p>
<blockquote>
<p>高水平的大锅饭比较好，没有竞争压力了，大家最独特的才华才会体现出来。</p>
</blockquote>
<p>可是只有当社会的水平达到一定程度才能这么玩儿，中国的体量，绝不可能做到如此宽松的地步，无论哪个阶层永远都有相当数量的人想改命，也就不能吃上大锅饭。小国寡民不适合中国。</p>
<blockquote>
<p>你自己有多聪明、能写多少书，这个很重要吗？关键是你能培养出什么人。那些真正厉害的人，带学生，一辈子写两三篇文章，就能改变人类历史。考申请课题搞出来的东西，到底有多大的价值，确实存疑</p>
</blockquote>
<p>那问题是：不是人人都能有这样的水平，但是却提供了大量的岗位，总不能为了宁缺毋滥不招人了吧，饭还是要吃的。</p>
<p>那么我们要做到：如果天才来了，别去挡他的路。</p>
<strong><h2 id="距离感与直接性" class="flex group">
<span>距离感与直接性</span>
<a href="#距离感与直接性"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>主体性不是说“我很厉害”、“我很特殊”，完全不是这个意思：而是说我作为一个人在这个世界上，我和世界是什么关系，我看到了什么，哪怕我的看法不对，但是应该把自己怎么想的搞清楚。</p>
</blockquote>
<p>先从问题出发，把自己想明白，项飙很强调想清楚自己，在认识世界之前，先要有自我。</p>
<blockquote>
<p>这跟你的物质利益到底有什么关系？要把这个问题讲清楚，你的行为才有意义。</p>
</blockquote>
<p>同时也讲实际，先不管情感上如何，能不能在硬件上先达到？这是一个可以去反推的手段。</p>
<blockquote>
<p>一定要有从内到外的冲击力，有情绪的积累。</p>
</blockquote>
<p>这是后期要做的事情，之前主动摒弃情感，现在把它再拿回来，做一个总结与积累，是一个过程的收尾。</p>
<strong><h2 id="非虚构写作" class="flex group">
<span>非虚构写作</span>
<a href="#非虚构写作"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>你要把自己是什么想清楚。“认命”是说从历史、结构的角度，想清楚自己是什么。</p>
</blockquote>
<p>这个对“认命”的解释令人耳目一新，回到之前论述的主题 → 想清楚自己是什么。</p>
<strong><h2 id="学术不是天职" class="flex group">
<span>学术不是天职</span>
<a href="#学术不是天职"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>“跨语言的自我”，翻译成为一种思想方法，朋友之间的交流也可以是一个方法，很重要的功能是逼着你去想这个about。</p>
</blockquote>
<p>两种文化的交锋，语言代表了背后的文化，是一种投影。使用双语就是在让自己在两种思考方式之间进行转化，可能产生很独特的、很好的、经过两种文化检验过的、真正了不起的东西。</p>
<p>但也可能四不像。</p>
<strong><h2 id="民族与民粹" class="flex group">
<span>民族与民粹</span>
<a href="#民族与民粹"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>清楚现实状况的人，文章是不可能写得那么正式的，因为事情非常复杂，搞出一二三四五六，只是贴标签，其实是不完全清楚。</p>
</blockquote>
<p>这个是我从未想到的，但可以解释一些现象。</p>
<blockquote>
<p>作为过渡，我就去了新加坡国立大学，在亚洲研究所做博后。新加坡国立大学对我生活的影响非常大，我在那里碰见了我的爱人，她也在亚洲研究所。</p>
</blockquote>
<p>所以说，你不知惊喜在哪里冒出来，不要放弃学习！</p>
<blockquote>
<p>新加坡最让我觉得可圈可点的地方，还不是像杜赞奇和安东尼-瑞德这样的一批人，而是他们背后一群兢兢业业的人。你可能从来没听过他们，他们往往都是女性，也许没有很大的想法，看起来没有什么天才的创造力，就是埋头苦干，有非常专业的精神，建立团队，有宽容的态度，做事情比较无私。</p>
</blockquote>
<p>新加坡的这样的一群人决定了所在群体的下限，他们也许上限没有多高，但是下限绝对不低。这是很重要的隐形实力。</p>
<p>联想到之前和某人关于对亚洲某发达国家的讨论，也许在那里有很多这样的人，无关男女。</p>
<blockquote>
<p>夸夸其谈相当可怕，好像一种灵感让自己感动起来，但是飘过去了就什么都没有。</p>
</blockquote>
<p>传神，无奈。</p>
<strong><h2 id="新加坡启蒙" class="flex group">
<span>新加坡启蒙</span>
<a href="#新加坡启蒙"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>她让我理解到电影、诗歌、艺术、民谣其实和学术一样，都是人类自我表达的方式。</p>
</blockquote>
<p>很多事情首先都是从认识自我开始，然后慢慢就有了表达欲。</p>
<blockquote>
<p>因为从小到大，学习是天职，从来不问为什么学习，没有想过学术和寓言其实是一回事，跟唱歌是一回事。</p>
</blockquote>
<p>我的启蒙从大学开始。我为什么学习，学习是什么这两个问题我已经有答案了。</p>
<p>首先回答第二个问题，学习是生活的必须，如果想要把自己的想法落实，学习是必要手段；其次，生活里基本所有的元素都可以通过学习重构，触发改变，这其中当然就包含了进步，这样也就回答了第一个问题，我想做到想做的事，因此要学习。</p>
<p>我现在认为学习是改变的一部分，同时也是改变的开端。</p>
<strong><h2 id="跨国性的自洽的小世界" class="flex group">
<span>跨国性的自洽的小世界</span>
<a href="#跨国性的自洽的小世界"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>这个小群体越是具备异质性、多样性，它的抵制的能力就越强，就会更加有机。</p>
</blockquote>
<p>这个对会议很有参考意义，我们应该一上来就去选择非常不一样的人，尽管会带来很多挑战。对于学习或者工作，这样的关系应该尚能维持。</p>
<blockquote>
<p>对于学者来讲，小世界首先是一个被构造的过程，其次是不断骚动的过程。你构造它，它逼着你，刺激你去反思自己，批评自己，不断冲破原来的理解。它越是活跃，越是骚动，给你的安全感越强，因为你的生存就是你的思考，如果不断觉得自己在思考，就很明确地感觉到自己在生存，不用为生存害怕，因为思想活着。</p>
</blockquote>
<p>构造是在满足表达欲，这个构造的过程会产生很多奇妙的反应，会改变你，持续不断。</p>
<p>项飙说生存就是思考，那么只要还在思考，我们就永生。</p>
<blockquote>
<p>真正的全球性只存在于无数的地方性之中。贝多芬是全世界的，但他首先是欧洲的，不是非洲的，不是拉美的。为什么欧洲的音乐家比非洲的音乐家更“全球”？这是个问题。</p>
</blockquote>
<p>前半句是在说万事皆有顺序，先小而大；后半句的观点其实很容易解释，欧洲有钱有技术，因此有人，非洲只有才华，冒不出头。</p>
<strong><h2 id="大学应该寻找例外" class="flex group">
<span>大学应该寻找例外</span>
<a href="#大学应该寻找例外"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>每个时代大学的功能都不一样。我们进入了一个物质相对充裕、城市教育水平相对高的时期，所以“人的生产”变得越来越重要。</p>
</blockquote>
<p>所以这是不是在说：从前的人没那么重要？</p>
<p>尽管真相不中听，现在的人，也没那么重要。大学确实应该认识到时代的召唤，进而改革，可是改革就要流血，不是每个人都愿意流血，你还不知道你的改革会让谁去流血。</p>
<p>因此先驱令人敬仰，不光是因为他们敢自己流血，而且也是因为他们做好了让大家都去流血的心理准备。</p>
<blockquote>
<p>大学不是去树立范例，而是要去寻找例外。</p>
</blockquote>
<p>这么看，现在的大学热衷于造神，离项飙的想法还远着，几近背道而驰。</p>
<p>大学不去寻找例外，我们自己去找，自己的、别人的、亲人朋友的、陌生人的，通通来者不拒。</p>
<blockquote>
<p>但是恢复高考把此前的官僚和城市知识分子一下子拢进来，其实是一个政党和当时社会主义体制下的精英的重新联盟。大学当然是搞精英主义，你看现在回忆恢复高考的人，很多都是干部子弟，从农村回到城市，不仅恢复了原来比较优越的地位，而且用这种途径在文化、道德上使自己的优越正当化、合法化。现在我们的大学是主流中的主流，大学也以此为豪。</p>
</blockquote>
<strong><h2 id="个人问题经验化" class="flex group">
<span>个人问题经验化</span>
<a href="#个人问题经验化"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>“打通”是什么意思，这个词我们已经说过很多遍了，打通就是回到实践，因为实践是最盘根、最通的！怎么样回到实践？从哪里回到实践？就是要从这些书本上学到的概念、范畴、理论、教条、框架离开，新的基础就是实践。但实践是那么流动、那么无情，怎么把握？个人经历就是开始把握的起点。</p>
</blockquote>
<p>在实践中总结自己的经验，反推回之前学的东西 → 解构、重构。</p>
<strong><h2 id="新研究" class="flex group">
<span>新研究</span>
<a href="#新研究"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>要真正通向上帝，必须通过自己的语境和语言，那是通向上帝唯一的思想途径。</p>
</blockquote>
<p>母语是根源，包容一切。人无法脱离根源，连上帝也不能免俗。</p>
<blockquote>
<p>现在我们共同的超越性的理想没有了，下面又没有空间，大家每天糊里糊涂。</p>
</blockquote>
<p>解放全人类的激情褪去之后，犹如理想破灭，那可不就是行尸走肉吗？原来是难得糊涂安慰自己，现在是醉生梦死麻痹自己。</p>
<blockquote>
<p>整个法律就写成让你时刻准备着离婚，有点这个意思。比方说两人结婚二十年，女方工资水平比较低，但对家庭付出大量的时间、精力的投入，到离婚时这些都不算，只算你名下登记的资产。《司法解释三》通过的背后的一个原因是说很多女性傍大款结婚，结婚后很快离婚，要拿一半财产，所以法律要保护大款。很明显，对比来看，就能看到法律对谁的声音更敏感。</p>
</blockquote>
<p>因此对于一些国家出台的政策，你要认真想一想到底和你有没有关系，不过大家也不是傻子，有很多人都很清醒。</p>
<p>某些话有人能听懂其中隐含的意思，可能是因为那些话是专门说给那些人听的。与你无关，你自然很难听懂，不要自作多情。</p>
<blockquote>
<p>但后来到现在，基本上就是城市里面受过高等教育的人在讨论，哪怕在社交媒体上，也很少听到工人的声音。</p>
</blockquote>
<p>这带来两个问题：</p>
<ol>
<li>
<p>社交媒体是否本身就具有门槛，将一些人置之门外？</p>
</li>
<li>
<p>工人也是人，也会有表达欲的需要，既然他们不在社交媒体上满足表达欲，那么是在哪里？</p>
</li>
</ol>
<p>回答：</p>
<ol>
<li>
<p>也许是，因为时代的受教育文化因素等影响，不过在可见的未来十几年，会有大量工人涌进互联网。</p>
</li>
<li>
<p>以我父辈为例，表达欲是在和朋友的现实交流中完成的，例如酒局，其实承担很大一部分的社交功能，即便看起来很没意思，但那是大家共同选择的游戏方式，想玩就得入局。</p>
</li>
</ol>
<strong><h2 id="共同理想" class="flex group">
<span>共同理想</span>
<a href="#共同理想"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>不是从理念上改变自己、重新树立理想，而是知道自己已经背叛了理想，现在要通过一切手段来自保，不允许任何人说话，所以现在的情况是比较复杂的。</p>
</blockquote>
<p>其实很可悲，但问题是，你的可悲不要来烦扰到我。可惜这种可悲更多意义上是一种奢侈品，绝非人人皆有，拥有它的人可以轻易影响别人的生活，这也是复杂的来源。</p>
<blockquote>
<p>现在世界的问题这么多，中国当然要努力走出不一样的路，但现在主流的心态，不是说要走不一样的路，而是取而代之，要当老大，很多基本的想法和美国非常类似，我觉得这和共同理想的丧失都有关系。中国在什么时候最令世界钦佩？那就是上世纪五六十年代。从万隆会议开始，到第三世界理论的提出，中国在国际上的影响非常大，引起了很多国际上的争论。</p>
</blockquote>
<p>这当然是理想破灭的后果之一，既然选择了不一样的路那就是必然，要了解过去，但不能沉湎。如果真的想重现当年的辉煌，那就重新走当年的老路，反之，洗洗睡吧。</p>
<blockquote>
<p>要证明自己其实就是没有自己，意思是说，要通过已经预设的原则和标准、别人的逻辑和流程来证明自己的存在，其实是取悦别人，把自己搞没有了。自我证明是很危险的。</p>
</blockquote>
<p>但在今天，想要活着，挣钱，就要时时刻刻证明自己，哪怕要牺牲自己。每个人都在这个罗网里没有解脱。也许在生产资料高度发达的、具有高度人类责任感的社会才能真正有尊严地活着吧。</p>
<strong><h2 id="乡绅作为方法" class="flex group">
<span>乡绅作为方法</span>
<a href="#乡绅作为方法"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>如果人民代表制度不能被有效激活，那么现在的政治环境里面，似乎没有什么真正的沟通渠道。– 吴琦</p>
</blockquote>
<p>谁说一流的知识分子对时局不清楚？他们明明清楚得很，还是不能小瞧任何人，收起对他们不切实际的想象，把自己作为方法，重新看待世界。</p>
<strong><h2 id="访谈之前" class="flex group">
<span>访谈之前</span>
<a href="#访谈之前"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>现在年轻人说，不用下结论，也不用从高大上的原则出发，就是讲自己的经验，经验比较琐碎，乱七八糟没有关系，只要是真的就有意义。这是一份从容和自信，这是相对新的， 跟年轻人的教育水平、城市化的生活方式都有关系。</p>
</blockquote>
<p>吃饱了之后会去想一想的人正在越来越多地浮现出来，毕竟思考也是一种活动。</p>
<p>思考之后，会有一些不一样的东西进来，包括自尊。</p>
<strong><h2 id="人的再生产" class="flex group">
<span>人的再生产</span>
<a href="#人的再生产"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>“人的再生产”跟“人的生产”不一样，“人的生产”是说人怎么样被培养成一个生产的要素， 而“人的再生产”就是人怎么样再生产自己，自己成为目标。</p>
</blockquote>
<p>让人成为真正的人，去做只有人才能胜任的事，让人类给人类自己存在的意义。</p>
<blockquote>
<p>再去看资本主义本身的变化，现在谁是赚钱的大户，平台可能是第一，第二就是跟“人的再生产”有关系的教育、医疗、娱乐等各种服务，接下来可能是采掘和农业，所谓第一产业。</p>
</blockquote>
<p>在人的再生产之前还有项目，说明我们还没有完全解放自己，不过我看情况已经很有转机，也许下一个阶段真的不远了。</p>
<blockquote>
<p>这也促使我思考如今“人的再生产”的问题，这其实是一个很重要的政治问题，看起来最不政治，但政治就在这里出现。</p>
</blockquote>
<p>在一定高度上看，政治无处不在。</p>
<p>今天的政治是否有了新的含义？不得而知。但可以肯定的是会有一些变化，围绕人的斗争形式上丰富起来几乎是一个必然结果，这也就导致了一些看起来不政治的问题实际上就是政治问题。</p>
<blockquote>
<p>政府鼓励的不是真正回国定居工作，而一般是短期回国甚至不回国服务，从回国服务变成为国服务，这是一个很大的转变。</p>
</blockquote>
<p>这里可以看出政府的格局，见过世面之后，“物以稀为贵”的“稀”会经过提纯，变得纯粹了起来；某些事上不再讲面子，而是要里子，底气足了之后做一些符合自己状态的事，这是政府的进步。</p>
<strong><h2 id="阶层流动的悖论" class="flex group">
<span>阶层流动的悖论</span>
<a href="#阶层流动的悖论"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>一个是到目前为止基本上大部分人还是往上流动，因为经济总量还是在扩张。第二个特征，中国的社会分化是一种全民参与式、以市场为基准的社会竞争。第三个特征，纵向分化又跟横向的流动紧密联系在一起。社交媒体分层又造成更大的分割、破碎化，很难形成动员，在思想表达上很同质。但像中国的这么大规模，人人都不认命，这可能不是经常出现的现象。</p>
</blockquote>
<p>原来有人往上流动是因为经济总量还在扩张才能办到，不是有人穷有人富的动态过程，而是有人如果富，很大可能会一直富下去。那么如果经济总量不再扩张，悲观看就不会再有新人富起来了。</p>
<p>仔细一想好像真的是这个道理，发达国家的阶级流动远远小于中国，只是他们的平民阶层相对优渥的生活掩盖了这些现象。天下的乌鸦很快就要一般黑了。</p>
<blockquote>
<p>现在我们好像被绑架了，一定要更高更快更强，正是因为不太愿意进行激烈的再分配，已经获得的人还要获得更多，同时又要把下面的人也提上去，这个确实很难，今后可能还是要慢慢走向再分配的思路。</p>
</blockquote>
<p>项飙认为今后可能要慢慢走向相对温和的再分配，我认为这将会是一个长期博弈过程，里面充满了变数，如果真有人人发财的路子，美国早就去做了。</p>
<p>再分配是历史发展的主旋律，小到劫富济贫，大到社会变化，都是这种主旋律的集中体现。联系到现在既去政治化又加强政治化的特点，我认为事情可能会走向最危险的境地，会发生相当剧烈的变革，然而变革之后又会是什么样子？天知道。</p>
<strong><h2 id="寻找新的话语" class="flex group">
<span>寻找新的话语</span>
<a href="#寻找新的话语"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>放在上世纪90年代或者2000年初， 那时还有关于左与右的讨论， 两边对于中国社会的描述以及背后的原因，都有具体的指向，比如左翼认为是资本主义这个大的系统出现问题，右翼说是权力本身的腐朽和话语的滞后。但现在一个很大的问题是，首先这个对立慢慢在消失，其次可能也因为对立的消失，公共话语本身也消失了，没有回应大家实际的感受，所以有一种普遍的不知所措。一方面感受到自己的生活出现了具体的变化，也包括进步，但另一方面又觉得不足够，不知道怎么理解，也不知道对抗什么，索性不想那么多，生活还能照样过，也蛮舒服。 – 吴琦</p>
</blockquote>
<p>这也是我看到的困惑，当吃饱了饭，矛盾没那么尖化的时候，似乎每个人都无所适从了，集体迷失方向感，再没有一个强人出来给大家指明方向，抑或者是人人都想得很明白，但又没有推广性，难以有沟通全员的共识存在。</p>
<blockquote>
<p>在今天，生活方式跟资本、国家权力同等重要。</p>
</blockquote>
<p>还是上述观点的延伸，饱暖思淫欲。</p>
<blockquote>
<p>文化这个概念可能会引起误解，一讲文化大家就觉得是文学、艺术，其实它就是指生活方式、日常经历、生活意义，包括抖音这些，六七十年代的文化研究，和在此之前的法兰克福学派给了我们很好的例子。</p>
</blockquote>
<p>原来我们觉得“粗俗”的东西实际上就是生活的一部分，然而经过一定程度的教育我们好像把“生活”本身视作一种“罪恶”，其实是不够了解自己。</p>
<blockquote>
<p>比方说我会倾向于去讲去政治化或者非政治化，比如物流型权力、基础设施权力，这些都是讲公共事务变得越来越被技术化地处理，人民内部矛盾用人民币解决，不管有理没理，就是给钱，对错不重要了，这就是我说的去政治化的意思。香港也是一样，商人治港，别问原则，老老实实做生意，其他的都无所谓，但是这个不可能长治久安。</p>
</blockquote>
<p>这样“简化”问题，其实是在逃避、偷懒，是在放弃对本质、对解释、对理解的追求。</p>
<blockquote>
<p>反思的意思是，你要阻止自己，要把自己停住，不要线性地往前冲，想一想为什么今天要这么做，不能用别的方式。</p>
</blockquote>
<p>这个讲的不好。反思应该是一种隐藏起来的本能，如果没有反思，人类不可能存活下来，面对这样一个没有天敌，只能内部竞争的环境，我们应该做的是找回自己的反思本能。</p>
<strong><h2 id="作为中介的人类学" class="flex group">
<span>作为中介的人类学</span>
<a href="#作为中介的人类学"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>一个好的范例超过很多理论。</p>
</blockquote>
<strong><h2 id="再谈乡绅" class="flex group">
<span>再谈乡绅</span>
<a href="#再谈乡绅"
   class="ml-2 inline-flex items-center opacity-0 border-0 group-hover:opacity-100"
   aria-label="Anchor">
    <div class="w-6 h-6 text-slate-400 ring-1 ring-slate-900/5 rounded-md shadow-sm flex items-center justify-center hover:ring-slate-900/10 hover:shadow hover:text-slate-700">
        <svg width="12" height="12" fill="none" aria-hidden="true">
            <path d="M3.75 1v10M8.25 1v10M1 3.75h10M1 8.25h10"
                  stroke="currentColor"
                  stroke-width="1.5"
                  stroke-linecap="round">
            </path>
        </svg>
    </div>
</a>
</h2>
</strong>
<blockquote>
<p>要成为一系列的叙述，一个强大的自觉，讲出来之后，能让你觉得站在这个世界上有根基，如果外面来的东西你觉得不懂，你就有勇气说不懂，说不喜欢。所谓知识就是对世界上发生了什么事有根有据的了解，从这里开始，去观察，去沉淀，慢慢沉淀出底气。</p>
</blockquote>
<p>相当于有了自己的“根”，一个坐标系里的参考点，从此有了空间。</p>
<hr />
<p>一本书最大的用处是给人改变，其次是给人思考，这本《把自己作为方法》二者皆有。里面最令人印象深刻的一句是：“不要拒绝理解”。这是我想法的盲区，也许在以后，我会再次翻看这本书，相信可以给我与此刻不一样的感受。</p>
]]>
        </content>

        <author>
            <name>whx</name>
        </author>
    </entry>
    </feed>
